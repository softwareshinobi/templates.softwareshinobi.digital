{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"bringing together the nation's best card players in a tournament near you.","text":"<p>Card Players Unite is a cloud agnostic data processing system built with Docker Containerization from the ground up.</p> <p></p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Try Card Players Unite</p>"},{"location":"#cloud-infrastructure","title":"Cloud Infrastructure","text":"<p>Containers on containers on containers. Well almost.</p> <p>The entirety of the Card Players Unite functionality is hosted in a private VPC in the Digital Ocean cloud.</p> <p>To learn more about the Card Players Unite cloud infrastructure and it's resources, see the link below.</p> <p>Read About The Cloud Infrastructure</p>"},{"location":"#software-architecture","title":"Software Architecture","text":"<p>I'll take \"a bunch of widgets talking to each other, for 500 Alex\".</p> <p>Card Players Unite hosts a number of software services to make the magic happen.</p> <p>From web servers, to APIs, to dashboards, etc.</p> <p>Learn more here...</p> <p>Read About The Software Architecture</p>"},{"location":"#source-code-repositories","title":"Source Code Repositories","text":"<p>The source code repositories supporting Card Players Unite is hosted in a GitHub Organization.</p> <p>In this GitHub organization you will find source code for the servers, dashboards, and other tooling.</p> <p>Go To GitHub Organization</p>"},{"location":"#automated-build-deploy","title":"Automated Build &amp; Deploy","text":"<p>The source code for Card Players Unite is built and deploy by a Dockerized Jenkins instance. This Jenkins instance polls the Card Players Unite GitHub organization on a timer.</p> <p>You can manage and the view the status of the Jenkins builds at the link below.</p> <p>Go To Jenkins Build Jobs</p>"},{"location":"#preview-card-players-unite","title":"Preview Card Players Unite","text":"<p>Car Players Unite has many components. If you don't know where to start, try the Tournament Site home.</p> <p>Try Card Players Unite</p>"},{"location":"01-cloud-infrastructure/","title":"Cloud Infrastructure Guide","text":"<p><code>kompose</code> has 3 stages: Loader, Transformer and Outputter. Each stage should have a well-defined interface, so it is easy to write a new Loader, Transformer, or Outputters and plug it in. Currently, only Loader and Transformer interfaces are defined.</p> <p></p>"},{"location":"01-cloud-infrastructure/#loader","title":"Loader","text":"<p>The Loader reads the input file now <code>kompose</code> supports Docker Compose v1, v2 and converts it to KomposeObject.</p> <p>Loader is represented by a Loader interface:</p> <pre><code>type Loader interface {\n      LoadFile(file string) kobject.KomposeObject\n}\n</code></pre> <p>Every loader \u201cimplementation\u201d should be placed into <code>kompose/pkg/loader</code> (like compose). More input formats will be supported in the future. You can take a look for more details at:</p> <ul> <li>kompose/pkg/loader</li> <li>kompose/pkg/loader/compose</li> </ul>"},{"location":"01-cloud-infrastructure/#komposeobject","title":"KomposeObject","text":"<p><code>KomposeObject</code> is Kompose internal representation of all containers loaded from input file. First version of <code>KomposeObject</code> looks like this (source: kobject.go):</p> <pre><code>// KomposeObject holds the generic struct of Kompose transformation\ntype KomposeObject struct {\n    ServiceConfigs map[string]ServiceConfig\n}\n\n// ServiceConfig holds the basic struct of a container\ntype ServiceConfig struct {\n    ContainerName string\n    Image         string\n    Environment   []EnvVar\n    Port          []Ports\n    Command       []string\n    WorkingDir    string\n    Args          []string\n    Volumes       []string\n    Network       []string\n    Labels        map[string]string\n    Annotations   map[string]string\n    CPUSet        string\n    CPUShares     int64\n    CPUQuota      int64\n    CapAdd        []string\n    CapDrop       []string\n    Entrypoint    []string\n    Expose        []string\n    Privileged    bool\n    Restart       string\n    User          string\n}\n</code></pre>"},{"location":"01-cloud-infrastructure/#transformer","title":"Transformer","text":"<p>The Transformer takes KomposeObject and converts it to target/output format (currently, there are sets of Kubernetes/OpenShift objects). Similar to the <code>Loader</code>, Transformer is represented by a Transformer interface:</p> <pre><code>type Transformer interface {\n     Transform(kobject.KomposeObject, kobject.ConvertOptions) []runtime.Object\n}\n</code></pre> <p>If you wish to add more providers containing different kinds of objects, the Transformer would be the place to look into. Currently, Kompose supports Kubernetes (by default) and OpenShift providers. More details at:</p> <ul> <li>kompose/pkg/transformer</li> <li>kompose/pkg/transformer/Kubernetes</li> <li>kompose/pkg/transformer/openshift</li> </ul>"},{"location":"01-cloud-infrastructure/#outputter","title":"Outputter","text":"<p>The Outputter takes the Transformer result and executes the given action. For example, action can display results to stdout or directly deploy artifacts to Kubernetes/OpenShift.</p>"},{"location":"software-architecture/","title":"Software Architecture","text":"<p><code>kompose</code> has 3 stages: Loader, Transformer and Outputter. Each stage should have a well-defined interface, so it is easy to write a new Loader, Transformer, or Outputters and plug it in. Currently, only Loader and Transformer interfaces are defined.</p> <p></p>"},{"location":"software-architecture/#loader","title":"Loader","text":"<p>The Loader reads the input file now <code>kompose</code> supports Docker Compose v1, v2 and converts it to KomposeObject.</p> <p>Loader is represented by a Loader interface:</p> <pre><code>type Loader interface {\n      LoadFile(file string) kobject.KomposeObject\n}\n</code></pre> <p>Every loader \u201cimplementation\u201d should be placed into <code>kompose/pkg/loader</code> (like compose). More input formats will be supported in the future. You can take a look for more details at:</p> <ul> <li>kompose/pkg/loader</li> <li>kompose/pkg/loader/compose</li> </ul>"},{"location":"software-architecture/#komposeobject","title":"KomposeObject","text":"<p><code>KomposeObject</code> is Kompose internal representation of all containers loaded from input file. First version of <code>KomposeObject</code> looks like this (source: kobject.go):</p> <pre><code>// KomposeObject holds the generic struct of Kompose transformation\ntype KomposeObject struct {\n    ServiceConfigs map[string]ServiceConfig\n}\n\n// ServiceConfig holds the basic struct of a container\ntype ServiceConfig struct {\n    ContainerName string\n    Image         string\n    Environment   []EnvVar\n    Port          []Ports\n    Command       []string\n    WorkingDir    string\n    Args          []string\n    Volumes       []string\n    Network       []string\n    Labels        map[string]string\n    Annotations   map[string]string\n    CPUSet        string\n    CPUShares     int64\n    CPUQuota      int64\n    CapAdd        []string\n    CapDrop       []string\n    Entrypoint    []string\n    Expose        []string\n    Privileged    bool\n    Restart       string\n    User          string\n}\n</code></pre>"},{"location":"software-architecture/#transformer","title":"Transformer","text":"<p>The Transformer takes KomposeObject and converts it to target/output format (currently, there are sets of Kubernetes/OpenShift objects). Similar to the <code>Loader</code>, Transformer is represented by a Transformer interface:</p> <pre><code>type Transformer interface {\n     Transform(kobject.KomposeObject, kobject.ConvertOptions) []runtime.Object\n}\n</code></pre> <p>If you wish to add more providers containing different kinds of objects, the Transformer would be the place to look into. Currently, Kompose supports Kubernetes (by default) and OpenShift providers. More details at:</p> <ul> <li>kompose/pkg/transformer</li> <li>kompose/pkg/transformer/Kubernetes</li> <li>kompose/pkg/transformer/openshift</li> </ul>"},{"location":"software-architecture/#outputter","title":"Outputter","text":"<p>The Outputter takes the Transformer result and executes the given action. For example, action can display results to stdout or directly deploy artifacts to Kubernetes/OpenShift.</p>"},{"location":"00-Cloud-infrastructure/1-coming-soon/","title":"card-players-unite / postgres-database [coming-soon]","text":""},{"location":"01-Wordpress-Server/1-coming-soon/","title":"card-players-unite / postgres-database [coming-soon]","text":""},{"location":"02-Postgres-Database/1-coming-soon/","title":"card-players-unite / postgres-database [coming-soon]","text":""},{"location":"03-Django-Rest-Api/1-django-rest-api/","title":"card-players-unite / django-rest-api","text":"<p>An official Kubernetes project, located at github.com/kubernetes/kompose Go from Docker Compose to Kubernetes.</p> <p></p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Live Demo</p>"},{"location":"03-Django-Rest-Api/1-django-rest-api/#installing-the-api","title":"Installing The API","text":"<p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Installation Guide</p>"},{"location":"03-Django-Rest-Api/1-django-rest-api/#get-started-with-the-api","title":"Get Started With The API","text":"<p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Getting Started</p>"},{"location":"03-Django-Rest-Api/1-django-rest-api/#activity-tracking","title":"Activity Tracking","text":"<p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>See The Kanban Board</p>"},{"location":"03-Django-Rest-Api/1-django-rest-api/#source-code-repository","title":"Source Code Repository","text":"<p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Go To GitHub</p>"},{"location":"03-Django-Rest-Api/1-django-rest-api/#build-deploy-automation","title":"Build &amp; Deploy Automation","text":"<p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Go To Jenkins</p>"},{"location":"03-Django-Rest-Api/1-django-rest-api/#api-user-guide","title":"API User Guide","text":"<p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Learn How To Use The API</p>"},{"location":"03-Django-Rest-Api/1-django-rest-api/#play-with-the-api","title":"Play With The API","text":"<p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <p>Live Demo</p>"},{"location":"03-Django-Rest-Api/conversion-detail-matrix/","title":"Conversion Matrix","text":"<ul> <li>TOC {:toc}</li> </ul> <p>This document outlines all possible conversion details regarding <code>docker-compose.yaml</code> values to Kubernetes / OpenShift artifacts.</p>"},{"location":"03-Django-Rest-Api/conversion-detail-matrix/#version-support","title":"Version Support","text":"<p>Under the hood, we're using compose-go, the reference library for parsing Compose files. We should be able to load all versions of Compose files. We're doing our best to keep it up to date as soon as possible in our releases to be compatible with the latest features defined in the Compose specification. If you absolutely need a feature we don't support yet, please open a PR!</p>"},{"location":"03-Django-Rest-Api/conversion-detail-matrix/#conversion-table","title":"Conversion Table","text":"<p>Glossary:</p> <ul> <li>\u2713: Converts</li> <li>-: Not in this Docker Compose Version</li> <li>n: Not yet implemented</li> <li>x: Not applicable / no 1-1 conversion</li> </ul> Keys V1 V2 V3 Kubernetes / OpenShift Notes build \u2713 \u2713 \u2713 Builds/Pushes to Docker repository. See user guide on build and push image build: context \u2713 \u2713 \u2713 build: dockerfile \u2713 \u2713 \u2713 build: args n n n build: cache_from - - n cap_add \u2713 \u2713 \u2713 Container.SecurityContext.Capabilities.Add cap_drop \u2713 \u2713 \u2713 Container.SecurityContext.Capabilities.Drop command \u2713 \u2713 \u2713 Container.Args configs n n \u2713 configs: short-syntax n n \u2713 Only create configMap configs: long-syntax n n \u2713 If target path is /, ignore this and only create configMap cgroup_parent x x x Not supported within Kubernetes. See issue https://github.com/kubernetes/kubernetes/issues/11986 container_name \u2713 \u2713 \u2713 Metadata.Name + Deployment.Spec.Containers.Name credential_spec x x x Only applicable to Windows containers deploy - - \u2713 deploy: mode - - \u2713 deploy: replicas - - \u2713 Deployment.Spec.Replicas / DeploymentConfig.Spec.Replicas deploy: placement - - \u2713 Affinity deploy: update_config - - \u2713 Workload.Spec.Strategy Deployment / DeploymentConfig deploy: resources - - \u2713 Containers.Resources.Limits.Memory / Containers.Resources.Limits.CPU Support for memory as well as cpu deploy: restart_policy - - \u2713 Pod generation This generated a Pod, see the user guide on restart deploy: labels - - \u2713 Workload.Metadata.Labels Only applied to workload resource devices x x x Not supported within Kubernetes, See issue https://github.com/kubernetes/kubernetes/issues/5607 depends_on x x x dns x x x Not used within Kubernetes. Kubernetes uses a managed DNS server dns_search x x x See <code>dns</code> key domainname \u2713 \u2713 \u2713 SubDomain tmpfs \u2713 \u2713 \u2713 Containers.Volumes.EmptyDir Creates emptyDirvolume with medium set to Memory &amp; mounts given directory inside container entrypoint \u2713 \u2713 \u2713 Container.Command env_file n n \u2713 environment \u2713 \u2713 \u2713 Container.Env expose \u2713 \u2713 \u2713 Service.Spec.Ports endpoint_mode n n \u2713 If endpoint_mode=vip, the created Service will be forced to set to NodePort type extends \u2713 \u2713 \u2713 Extends by utilizing the same image supplied external_links x x x Kubernetes uses a flat-structure for all containers and thus external_links does not have a 1-1 conversion extra_hosts n n n group_add \u2713 \u2713 \u2713 healthcheck - n \u2713 hostname \u2713 \u2713 \u2713 HostName image \u2713 \u2713 \u2713 Deployment.Spec.Containers.Image isolation x x x Not applicable as this applies to Windows with HyperV support labels \u2713 \u2713 \u2713 Metadata.Annotations links x x x All containers in the same pod are accessible in Kubernetes logging x x x Kubernetes has built-in logging support at the node-level network_mode x x x Kubernetes uses its own cluster networking networks \u2713 \u2713 \u2713 See <code>networks</code> key networks: aliases x x x See <code>networks</code> key networks: addresses x x x See <code>networks</code> key pid \u2713 \u2713 \u2713 HostPID ports \u2713 \u2713 \u2713 Service.Spec.Ports ports: short-syntax \u2713 \u2713 \u2713 Service.Spec.Ports ports: long-syntax - - \u2713 Service.Spec.Ports secrets - - \u2713 Secret External Secret is not Supported secrets: short-syntax - - \u2713 Secret External Secret is not Supported secrets: long-syntax - - \u2713 Secret External Secret is not Supported security_opt x x x Kubernetes uses its own container naming scheme stop_grace_period \u2713 \u2713 \u2713 TerminationGracePeriodSeconds stop_signal x x x Not supported within Kubernetes. See issue https://github.com/kubernetes/kubernetes/issues/30051 sysctls n n n ulimits x x x Not supported within Kubernetes. See issue https://github.com/kubernetes/kubernetes/issues/3595 userns_mode x x x Not supported within Kubernetes and ignored in Docker Compose Version 3 volumes \u2713 \u2713 \u2713 PersistentVolumeClaim Creates a PersistentVolumeClaim. Can only be created if there is already a PersistentVolume within the cluster volumes: short-syntax \u2713 \u2713 \u2713 PersistentVolumeClaim Creates a PersistentVolumeClaim. Can only be created if there is already a PersistentVolume within the cluster volumes: long-syntax - - \u2713 PersistentVolumeClaim Creates a PersistentVolumeClaim. Can only be created if there is already a PersistentVolume within the cluster restart \u2713 \u2713 \u2713 Volume x x x driver x x x driver_opts x x x external x x x labels x x x Network x x x driver x x x driver_opts x x x enable_ipv6 x x x ipam x x x internal x x x labels x x x external x x x"},{"location":"03-Django-Rest-Api/development-guide/","title":"Development Guide","text":""},{"location":"03-Django-Rest-Api/development-guide/#building-kompose","title":"Building Kompose","text":"<p>Read about building kompose here.</p>"},{"location":"03-Django-Rest-Api/development-guide/#workflow","title":"Workflow","text":""},{"location":"03-Django-Rest-Api/development-guide/#fork-the-main-repository","title":"Fork the main repository","text":"<ol> <li>Go to https://github.com/kubernetes/kompose</li> <li>Click the \"Fork\" button (at the top right)</li> </ol>"},{"location":"03-Django-Rest-Api/development-guide/#clone-your-fork","title":"Clone your fork","text":"<p>The commands below require that you have <code>$GOPATH</code>. We highly recommended you put the Kompose code into your <code>$GOPATH</code>.</p> <pre><code>git clone https://github.com/$YOUR_GITHUB_USERNAME/kompose.git $GOPATH/src/github.com/kubernetes/kompose\ncd $GOPATH/src/github.com/kubernetes/kompose\ngit remote add upstream 'https://github.com/kubernetes/kompose'\n</code></pre>"},{"location":"03-Django-Rest-Api/development-guide/#create-a-branch-and-make-changes","title":"Create a branch and make changes","text":"<pre><code>git checkout -b myfeature\n# Make your code changes\n</code></pre>"},{"location":"03-Django-Rest-Api/development-guide/#keeping-your-development-fork-in-sync","title":"Keeping your development fork in sync","text":"<pre><code>git fetch upstream\ngit rebase upstream/main\n</code></pre> <p>Note: If you have write access to the main repository at github.com/kubernetes/kompose, you should modify your git configuration so that you can't accidentally push to upstream:</p> <pre><code>git remote set-url --push upstream no_push\n</code></pre>"},{"location":"03-Django-Rest-Api/development-guide/#committing-changes-to-your-fork","title":"Committing changes to your fork","text":"<pre><code>git commit\ngit push -f origin myfeature\n</code></pre>"},{"location":"03-Django-Rest-Api/development-guide/#creating-a-pull-request","title":"Creating a pull request","text":"<ol> <li>Visit https://github.com/$YOUR_GITHUB_USERNAME/kompose.git</li> <li>Click the \"Compare and pull request\" button next to your \"myfeature\" branch.</li> <li>Check out the pull request process for more details</li> </ol>"},{"location":"03-Django-Rest-Api/development-guide/#go-modules-and-dependency-management","title":"Go Modules and dependency management","text":"<p>Kompose uses Go Modules to manage dependencies. If you want to introduce changes to dependencies, please ensure that <code>go.mod</code> and <code>go.sum</code> are updated properly.</p>"},{"location":"03-Django-Rest-Api/development-guide/#updating-kubernetes-and-openshift","title":"Updating Kubernetes and OpenShift","text":"<p>Kubernetes version depends on what version is OpenShift using. OpenShift is using forked Kubernetes to carry some patches. Currently, it is not possible to use a different Kubernetes version from the version that OpenShift uses. (for more see comments in <code>go.mod</code>)</p>"},{"location":"03-Django-Rest-Api/development-guide/#adding-cli-tests","title":"Adding CLI tests","text":"<p>Kompose CLI tests run <code>kompose convert</code> with docker-compose files, and cross-check the k8s and OpenShift artifacts generated with the template files.</p> <p>To generate CLI tests, please run <code>make gen-cmd</code>.</p>"},{"location":"03-Django-Rest-Api/development-guide/#ci","title":"CI","text":"<p>For Kompose, we use numerous CI's:</p> <ul> <li>TravisCI: Unit and CLI tests</li> <li>SemaphoreCI: Integration / cluster tests</li> <li>Fabric8CI: Secondary integration tests / future cluster tests</li> </ul>"},{"location":"03-Django-Rest-Api/getting-started-guide/","title":"Getting Started Guide","text":"<p>This is how you'll get started with Kompose!</p> <p></p> <p>There are three different guides depending on your container orchestrator as well as operating system.</p> <p>For beginners and the most compatibility, follow the Minikube and Kompose guide.</p>"},{"location":"03-Django-Rest-Api/getting-started-guide/#minikube-and-kompose","title":"Minikube and Kompose","text":"<p>In this guide, we'll deploy a sample <code>docker-compose.yaml</code> file to a Kubernetes cluster.</p> <p>Requirements:</p> <ul> <li>minikube</li> <li>kompose</li> </ul> <p>Start <code>minikube</code>:</p> <p>If you don't already have a Kubernetes cluster running, minikube is the best way to get started.</p> <pre><code>$ minikube start\nStarting local Kubernetes v1.7.5 cluster...\nStarting VM...\nGetting VM IP address...\nMoving files into cluster...\nSetting up certs...\nConnecting to cluster...\nSetting up kubeconfig...\nStarting cluster components...\nKubectl is now configured to use the cluster\n</code></pre> <p>Download an example Docker Compose file, or use your own:</p> <pre><code>wget https://raw.githubusercontent.com/kubernetes/kompose/main/examples/docker-compose.yaml\n</code></pre> <p>Convert your Docker Compose file to Kubernetes:</p> <p>Run <code>kompose convert</code> in the same directory as your <code>docker-compose.yaml</code> file.</p> <pre><code>$ kompose convert\nINFO Kubernetes file \"frontend-service.yaml\" created\nINFO Kubernetes file \"redis-master-service.yaml\" created\nINFO Kubernetes file \"redis-replica-service.yaml\" created\nINFO Kubernetes file \"frontend-deployment.yaml\" created\nINFO Kubernetes file \"redis-master-deployment.yaml\" created\nINFO Kubernetes file \"redis-replica-deployment.yaml\" created\n</code></pre> <p>Then you can use <code>kubectl apply</code> to create these resources in Kubernetes.</p> <p>Access the newly deployed service:</p> <p>Now that your service has been deployed, let's access it.</p> <p>If you're using <code>minikube</code> you may access it via the <code>minikube service</code> command.</p> <pre><code>$ minikube service frontend\n</code></pre> <p>Otherwise, use <code>kubectl</code> to see what IP the service is using:</p> <pre><code>$ kubectl describe svc frontend\nName:                   frontend\nNamespace:              default\nLabels:                 service=frontend\nSelector:               service=frontend\nType:                   LoadBalancer\nIP:                     10.0.0.183\nLoadBalancer Ingress:   123.45.67.89\nPort:                   80      80/TCP\nNodePort:               80      31144/TCP\nEndpoints:              172.17.0.4:80\nSession Affinity:       None\nNo events.\n</code></pre> <p>Note: If you're using a cloud provider, your IP will be listed next to <code>LoadBalancer Ingress</code>.</p> <p>If you have yet to expose your service (for example, within GCE), use the command:</p> <pre><code>kubectl expose deployment frontend --type=\"LoadBalancer\"\n</code></pre> <p>To check functionality, you may also <code>curl</code> the URL.</p> <pre><code>$ curl http://123.45.67.89\n</code></pre>"},{"location":"03-Django-Rest-Api/getting-started-guide/#minishift-and-kompose","title":"Minishift and Kompose","text":"<p>In this guide, we'll deploy a sample <code>docker-compose.yaml</code> file to an OpenShift cluster.</p> <p>Requirements:</p> <ul> <li>minishift</li> <li>kompose</li> <li>An OpenShift route created</li> </ul> <p>Note: The service will NOT be accessible until you create an OpenShift route with <code>oc expose</code>. You must also have a virtualization environment setup. By default, <code>minishift</code> uses KVM.</p> <p>Start <code>minishift</code>:</p> <p>Minishift is a tool that helps run OpenShift locally using a single-node cluster inside a VM. Similar to minikube.</p> <pre><code>$ minishift start\nStarting local OpenShift cluster using 'kvm' hypervisor...\n-- Checking OpenShift client ... OK\n-- Checking Docker client ... OK\n-- Checking Docker version ... OK\n-- Checking for existing OpenShift container ... OK\n...\n</code></pre> <p>Download an example Docker Compose file, or use your own:</p> <pre><code>wget https://raw.githubusercontent.com/kubernetes/kompose/main/examples/docker-compose.yaml\n</code></pre> <p>Convert your Docker Compose file to OpenShift:</p> <p>Run <code>kompose convert --provider=openshift</code> in the same directory as your <code>docker-compose.yaml</code> file.</p> <pre><code>$ kompose convert --provider=openshift\nINFO OpenShift file \"frontend-service.yaml\" created\nINFO OpenShift file \"redis-master-service.yaml\" created\nINFO OpenShift file \"redis-replica-service.yaml\" created\nINFO OpenShift file \"frontend-deploymentconfig.yaml\" created\nINFO OpenShift file \"frontend-imagestream.yaml\" created\nINFO OpenShift file \"redis-master-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-master-imagestream.yaml\" created\nINFO OpenShift file \"redis-replica-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-replica-imagestream.yaml\" created\n</code></pre> <p>Then you can use <code>kubectl apply</code> to create these resources in OpenShift cluster.</p> <p>Access the newly deployed service:</p> <p>After deployment, you must create an OpenShift route in order to access the service.</p> <p>If you're using <code>minishift</code>, you'll use a combination of <code>oc</code> and <code>minishift</code> commands to access the service.</p> <p>Create a route for the <code>frontend</code> service using <code>oc</code>:</p> <pre><code>$ oc expose service/frontend\nroute \"frontend\" exposed\n</code></pre> <p>Access the <code>frontend</code> service with <code>minishift</code>:</p> <pre><code>$ minishift openshift service frontend --namespace=myproject\nOpening the service myproject/frontend in the default browser...\n</code></pre> <p>You can also access the GUI interface of OpenShift for an overview of the deployed containers:</p> <pre><code>$ minishift console\nOpening the OpenShift Web console in the default browser...\n</code></pre>"},{"location":"03-Django-Rest-Api/getting-started-guide/#rhel-and-kompose","title":"RHEL and Kompose","text":"<p>In this guide, we'll deploy a sample <code>docker-compose.yaml</code> file using both RHEL (Red Hat Enterprise Linux) and OpenShift.</p> <p>Requirements:</p> <ul> <li>Red Hat Enterprise Linux 7.4</li> <li>Red Hat Development Suite</li> <li>Which includes:</li> <li>minishift</li> <li>kompose</li> </ul> <p>Note: A KVM hypervisor must be setup in order to correctly use <code>minishift</code> on RHEL. You can set it up via the CDK Documentation under \"Set up your virtualization environment\".</p> <p>Install Red Hat Development Suite:</p> <p>Before we are able to use both <code>minishift</code> and <code>kompose</code>, DevSuite must be installed. A more concise installation document is available.</p> <p>Change to root.</p> <pre><code>$ su -\n</code></pre> <p>Enable the Red Hat Developer Tools software repository.</p> <pre><code>$ subscription-manager repos --enable rhel-7-server-devtools-rpms\n$ subscription-manager repos --enable rhel-server-rhscl-7-rpms\n</code></pre> <p>Add the Red Hat Developer Tools key to your system.</p> <pre><code>$ cd /etc/pki/rpm-gpg\n$ wget -O RPM-GPG-KEY-redhat-devel https://www.redhat.com/security/data/a5787476.txt\n$ rpm --import RPM-GPG-KEY-redhat-devel\n</code></pre> <p>Install Red Hat Development Suite and Kompose.</p> <pre><code>$ yum install rh-devsuite kompose -y\n</code></pre> <p>Start <code>minishift</code>:</p> <p>Before we begin, we must do a few preliminary steps setting up <code>minishift</code>.</p> <pre><code>$ su -\n$ ln -s /var/lib/cdk-minishift-3.0.0/minishift /usr/bin/minishift\n$ minishift setup-cdk --force --default-vm-driver=\"kvm\"\n$ ln -s /home/$(whoami)/.minishift/cache/oc/v3.5.5.8/oc /usr/bin/oc\n</code></pre> <p>Now we may start <code>minishift</code>.</p> <pre><code>$ minishift start\nStarting local OpenShift cluster using 'kvm' hypervisor...\n-- Checking OpenShift client ... OK\n-- Checking Docker client ... OK\n-- Checking Docker version ... OK\n-- Checking for existing OpenShift container ... OK\n...\n</code></pre> <p>Download an example Docker Compose file, or use your own:</p> <pre><code>wget https://raw.githubusercontent.com/kubernetes/kompose/main/examples/docker-compose.yaml\n</code></pre> <p>Convert your Docker Compose file to OpenShift:</p> <p>Run <code>kompose convert --provider=openshift</code> in the same directory as your <code>docker-compose.yaml</code> file.</p> <pre><code>$ kompose convert --provider=openshift\nINFO OpenShift file \"frontend-service.yaml\" created\nINFO OpenShift file \"redis-master-service.yaml\" created\nINFO OpenShift file \"redis-replica-service.yaml\" created\nINFO OpenShift file \"frontend-deploymentconfig.yaml\" created\nINFO OpenShift file \"frontend-imagestream.yaml\" created\nINFO OpenShift file \"redis-master-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-master-imagestream.yaml\" created\nINFO OpenShift file \"redis-replica-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-replica-imagestream.yaml\" created\n</code></pre> <p>Then you can use <code>kubectl apply</code> to create these resources in OpenShift.</p> <p>Access the newly deployed service:</p> <p>After deployment, you must create an OpenShift route in order to access the service.</p> <p>If you're using <code>minishift</code>, you'll use a combination of <code>oc</code> and <code>minishift</code> commands to access the service.</p> <p>Create a route for the <code>frontend</code> service using <code>oc</code>:</p> <pre><code>$ oc expose service/frontend\nroute \"frontend\" exposed\n</code></pre> <p>Access the <code>frontend</code> service with <code>minishift</code>:</p> <pre><code>$ minishift openshift service frontend --namespace=myproject\nOpening the service myproject/frontend in the default browser...\n</code></pre> <p>You can also access the GUI interface of OpenShift for an overview of the deployed containers:</p> <pre><code>$ minishift console\nOpening the OpenShift Web console in the default browser...\n</code></pre>"},{"location":"03-Django-Rest-Api/how-to-article/","title":"Fabric8 Maven Plugin + Kompose:","text":"<p>Let's deploy a Springboot Java application with Docker Compose file using Fabric8 Maven Plugin to Kubernetes or OpenShift.</p>"},{"location":"03-Django-Rest-Api/how-to-article/#requirements","title":"Requirements","text":"<ul> <li>Linux or MacOS or Windows</li> <li>JDK 1.7+ - JDK Quick Installation Guide</li> <li>Maven 3.x+ - Maven Installation Guide</li> <li>Kompose - Kompose Installation Guide</li> </ul> <p>1. Clone the example project from GitHub</p> <pre><code>$ git clone https://github.com/piyush1594/kompose-maven-example.git\n</code></pre> <p>Change current directory to <code>kompose-maven-example</code> directory.</p> <pre><code>$ cd kompose-maven-example\n</code></pre> <p>2. Add Fabric8 Maven Plugin to your project</p> <pre><code>$ mvn io.fabric8:fabric8-maven-plugin:3.5.28:setup\n</code></pre> <p>Add the Fabric8 Maven Plugin configuration to <code>pom.xml</code> of project. <code>pom.xml</code> is manifest or deployment descriptor file of a maven project.</p> <p>3. Install Kompose through Maven</p> <pre><code>$ mvn fabric8:install\n</code></pre> <p>This command installs the <code>kompose</code> on the host.</p> <p>4. Configure Fabric8 Maven Plugin to use a Docker Compose file</p> <pre><code>&lt;plugin&gt;\n  &lt;groupId&gt;io.fabric8&lt;/groupId&gt;\n  &lt;artifactId&gt;fabric8-maven-plugin&lt;/artifactId&gt;\n  &lt;configuration&gt;\n    &lt;composeFile&gt;path for docker compose file&lt;/composeFile&gt;\n  &lt;/configuration&gt;\n  &lt;executions&gt;\n    &lt;execution&gt;\n      &lt;goals&gt;\n        &lt;goal&gt;resource&lt;/goal&gt;\n        &lt;goal&gt;build&lt;/goal&gt;\n      &lt;/goals&gt;\n    &lt;/execution&gt;\n  &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Add the <code>&lt;configuration&gt;</code> and <code>&lt;executions&gt;</code> sections to <code>pom.xml</code> as shown in above <code>pom.xml</code> snippet. Update the <code>&lt;composeFile&gt;</code> to provide the relative path of Docker Compose file from <code>pom.xml</code></p> <p>5. Deploy application on Kubernetes or OpenShift</p> <p>Make sure that Kubernetes/OpenShift cluster or Minikube/Minishift is running. In case, if anything of this is not running, you can run Minishift to test this application by using the following command.</p> <pre><code>$ minishift start\n</code></pre> <p>Below command deploys this application on Kubernetes or OpenShift.</p> <pre><code>$ mvn fabric8:deploy\n</code></pre> <p>Now that your service has been deployed, let's access it by querying <code>pod</code>, <code>service</code> from Kubernetes or OpenShift.</p> <pre><code>$ oc get pods\nNAME                                    READY     STATUS      RESTARTS   AGE\nspringboot-docker-compose-1-xl0vb       1/1       Running     0          5m\nspringboot-docker-compose-s2i-1-build   0/1       Completed   0          7m\n</code></pre> <pre><code>$ oc get svc\nNAME                        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE\nspringboot-docker-compose   172.30.205.137   &lt;none&gt;        8080/TCP   6m\n</code></pre> <p>Let's access the Springboot service.</p> <pre><code>$ minishift openshift service --in-browser springboot-docker-compose\nCreated the new window in existing browser session.\n</code></pre> <p>It will open your application endpoint in default browser.</p> <p></p>"},{"location":"03-Django-Rest-Api/installation-guide/","title":"Konsole Installation Guide","text":"<p>We have multiple ways to install Kompose. Our preferred (and most up-to-date) method is downloading the binary from the latest GitHub release.</p> <p></p>"},{"location":"03-Django-Rest-Api/installation-guide/#download-github-releases","title":"Download GitHub Releases","text":"<p>Kompose is released via GitHub, you can see all current releases on the GitHub release page.</p>"},{"location":"03-Django-Rest-Api/installation-guide/#github-release-for-linux","title":"Github Release For Linux","text":"<pre><code>\ncurl -L https://github.com/kubernetes/kompose/releases/download/v1.30.0/kompose-linux-amd64 -o kompose\n\n</code></pre>"},{"location":"03-Django-Rest-Api/installation-guide/#github-release-for-macos","title":"Github Release For macOS","text":"<pre><code>curl -L https://github.com/kubernetes/kompose/releases/download/v1.30.0/kompose-darwin-amd64 -o kompose\n\nchmod +x kompose\n\nsudo mv ./kompose /usr/local/bin/kompose\n</code></pre>"},{"location":"03-Django-Rest-Api/installation-guide/#github-release-for-windows","title":"Github Release For Windows","text":"<p>Download from GitHub and add the binary to your PATH.</p>"},{"location":"03-Django-Rest-Api/installation-guide/#go","title":"Go","text":"<p>Installing using <code>go install</code> pulls from the main branch with the latest development changes.</p> <pre><code>go install github.com/kubernetes/kompose@latest\n</code></pre>"},{"location":"03-Django-Rest-Api/installation-guide/#centos","title":"CentOS","text":"<p>Kompose is in EPEL CentOS repository. If you don't have EPEL repository already installed and enabled you can do it by running <code>sudo yum install epel-release</code></p> <p>If you have EPEL enabled in your system, you can install Kompose like any other package.</p> <pre><code>sudo yum -y install kompose\n</code></pre>"},{"location":"03-Django-Rest-Api/installation-guide/#fedora","title":"Fedora","text":"<p>Kompose is in Fedora 24, 25 and 26 repositories. You can install it just like any other package.</p> <pre><code>sudo dnf -y install kompose\n</code></pre>"},{"location":"03-Django-Rest-Api/installation-guide/#macos","title":"macOS","text":"<p>On macOS, you can install the latest release via Homebrew or MacPorts.</p> <pre><code>brew install kompose\n</code></pre>"},{"location":"03-Django-Rest-Api/installation-guide/#windows","title":"Windows","text":"<p>Kompose can be installed via Chocolatey</p> <pre><code>choco install kubernetes-kompose\n</code></pre> <p>or using winget</p> <pre><code>winget install Kubernetes.kompose\n</code></pre>"},{"location":"03-Django-Rest-Api/installation-guide/#docker","title":"Docker","text":"<p>You can build an image from the official repo for Docker or Podman:</p> <pre><code>docker build -t kompose https://github.com/kubernetes/kompose.git\\#main\n</code></pre> <p>To run the built image against the current directory, run the following command:</p> <pre><code>docker run --rm -it -v $PWD:/opt kompose sh -c \"cd /opt &amp;&amp; kompose convert\"\n</code></pre>"},{"location":"03-Django-Rest-Api/software-architecture-guide/","title":"Architecture and Internal Design","text":"<ul> <li>TOC {:toc}</li> </ul> <p><code>kompose</code> has 3 stages: Loader, Transformer and Outputter. Each stage should have a well-defined interface, so it is easy to write a new Loader, Transformer, or Outputters and plug it in. Currently, only Loader and Transformer interfaces are defined.</p> <p></p>"},{"location":"03-Django-Rest-Api/software-architecture-guide/#loader","title":"Loader","text":"<p>The Loader reads the input file now <code>kompose</code> supports Docker Compose v1, v2 and converts it to KomposeObject.</p> <p>Loader is represented by a Loader interface:</p> <pre><code>type Loader interface {\n      LoadFile(file string) kobject.KomposeObject\n}\n</code></pre> <p>Every loader \u201cimplementation\u201d should be placed into <code>kompose/pkg/loader</code> (like compose). More input formats will be supported in the future. You can take a look for more details at:</p> <ul> <li>kompose/pkg/loader</li> <li>kompose/pkg/loader/compose</li> </ul>"},{"location":"03-Django-Rest-Api/software-architecture-guide/#komposeobject","title":"KomposeObject","text":"<p><code>KomposeObject</code> is Kompose internal representation of all containers loaded from input file. First version of <code>KomposeObject</code> looks like this (source: kobject.go):</p> <pre><code>// KomposeObject holds the generic struct of Kompose transformation\ntype KomposeObject struct {\n    ServiceConfigs map[string]ServiceConfig\n}\n\n// ServiceConfig holds the basic struct of a container\ntype ServiceConfig struct {\n    ContainerName string\n    Image         string\n    Environment   []EnvVar\n    Port          []Ports\n    Command       []string\n    WorkingDir    string\n    Args          []string\n    Volumes       []string\n    Network       []string\n    Labels        map[string]string\n    Annotations   map[string]string\n    CPUSet        string\n    CPUShares     int64\n    CPUQuota      int64\n    CapAdd        []string\n    CapDrop       []string\n    Entrypoint    []string\n    Expose        []string\n    Privileged    bool\n    Restart       string\n    User          string\n}\n</code></pre>"},{"location":"03-Django-Rest-Api/software-architecture-guide/#transformer","title":"Transformer","text":"<p>The Transformer takes KomposeObject and converts it to target/output format (currently, there are sets of Kubernetes/OpenShift objects). Similar to the <code>Loader</code>, Transformer is represented by a Transformer interface:</p> <pre><code>type Transformer interface {\n     Transform(kobject.KomposeObject, kobject.ConvertOptions) []runtime.Object\n}\n</code></pre> <p>If you wish to add more providers containing different kinds of objects, the Transformer would be the place to look into. Currently, Kompose supports Kubernetes (by default) and OpenShift providers. More details at:</p> <ul> <li>kompose/pkg/transformer</li> <li>kompose/pkg/transformer/Kubernetes</li> <li>kompose/pkg/transformer/openshift</li> </ul>"},{"location":"03-Django-Rest-Api/software-architecture-guide/#outputter","title":"Outputter","text":"<p>The Outputter takes the Transformer result and executes the given action. For example, action can display results to stdout or directly deploy artifacts to Kubernetes/OpenShift.</p>"},{"location":"03-Django-Rest-Api/software-licenses/","title":"Integrations","text":"<ul> <li>TOC {:toc}</li> </ul> <p>There are some projects out there known to use Kompose integrated in some form or another</p>"},{"location":"03-Django-Rest-Api/software-licenses/#kompose-ui-by-jad-chamoun-icann-and-joe-haddad-anghami","title":"Kompose UI by Jad Chamoun (ICANN) and Joe Haddad (Anghami)","text":"<p>Description: \"A web interface to convert Docker Compose files to Kubernetes YAML\"</p> <p>Link: https://github.com/JadCham/komposeui</p>"},{"location":"03-Django-Rest-Api/software-licenses/#kompose-docker-container-by-cloudfind","title":"Kompose Docker Container by Cloudfind","text":"<p>Description: \"A Docker container for the Kompose translator for docker-compose\"</p> <p>Link: https://github.com/cloudfind/kompose-docker</p>"},{"location":"03-Django-Rest-Api/software-licenses/#kpm-by-coreos","title":"KPM by CoreOS","text":"<p>Description: \"KPM is a tool to deploy and manage application stacks on Kubernetes\"</p> <p>Link: https://github.com/coreos/kpm</p>"},{"location":"03-Django-Rest-Api/software-licenses/#docker-image-for-adobe-enterprise-manager-by-adfinis-sygroup-ag","title":"Docker Image for Adobe Enterprise Manager by Adfinis SyGroup AG","text":"<p>Description: \"Docker Image for Adobe Enterprise Manager\"</p> <p>Link: https://github.com/adfinis-sygroup/aem-docker/tree/master</p>"},{"location":"03-Django-Rest-Api/software-licenses/#kompose-ansible-playbook-by-chris-houseknecht-red-hat","title":"Kompose Ansible Playbook by Chris Houseknecht (Red Hat)","text":"<p>Description: \"Download and unarchive the latest kompose release asset for your OS\"</p> <p>Link: https://github.com/chouseknecht/kompose-install-role</p>"},{"location":"03-Django-Rest-Api/software-licenses/#fabric8-maven-plugin-by-red-hat","title":"Fabric8 Maven Plugin by Red Hat","text":"<p>Description: \"Maven is one of the widely used build tools for Java applications. The Fabric8 Maven Plugin is a maven extension that simplifies the deployment of Java applications to Kubernetes or OpenShift clusters. The main task of this plugin is to build Docker images, generate Kubernetes or OpenShift resource descriptors and run/deploy the application on Kubernetes or OpenShift cluster. The plugin has a wide range of configuration options. Docker Compose is one of the options to bring up deployments on Kubernetes or OpenShift clusters. Technically, Fabric8 Maven Plugin processes the external docker-compose.yml file and generates Kubernetes or OpenShift resources via Kompose.\"</p> <p>Links:</p> <ul> <li>Quickstart</li> <li>Documentation</li> </ul>"},{"location":"03-Django-Rest-Api/user-guide/","title":"User Guide","text":"<p>Kompose has support for two providers: OpenShift and Kubernetes.</p> <p></p> <p>You can choose a targeted provider using global option <code>--provider</code>. If no provider is specified, Kubernetes is set by default.</p>"},{"location":"03-Django-Rest-Api/user-guide/#kompose-convert","title":"Kompose Convert","text":"<p>Kompose supports conversion of V1, V2, and V3 Docker Compose files into Kubernetes and OpenShift objects.</p>"},{"location":"03-Django-Rest-Api/user-guide/#kubernetes","title":"Kubernetes","text":"<pre><code>$ kompose --file docker-voting.yml convert\nWARN Unsupported key networks - ignoring\nWARN Unsupported key build - ignoring\nINFO Kubernetes file \"worker-svc.yaml\" created\nINFO Kubernetes file \"db-svc.yaml\" created\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"result-svc.yaml\" created\nINFO Kubernetes file \"vote-svc.yaml\" created\nINFO Kubernetes file \"redis-deployment.yaml\" created\nINFO Kubernetes file \"result-deployment.yaml\" created\nINFO Kubernetes file \"vote-deployment.yaml\" created\nINFO Kubernetes file \"worker-deployment.yaml\" created\nINFO Kubernetes file \"db-deployment.yaml\" created\n\n$ ls\ndb-deployment.yaml  docker-compose.yml         docker-gitlab.yml  redis-deployment.yaml  result-deployment.yaml  vote-deployment.yaml  worker-deployment.yaml\ndb-svc.yaml         docker-voting.yml          redis-svc.yaml     result-svc.yaml        vote-svc.yaml           worker-svc.yaml\n</code></pre> <p>You can also provide multiple docker-compose files at the same time:</p> <pre><code>$ kompose -f docker-compose.yml -f docker-guestbook.yml convert\nINFO Kubernetes file \"frontend-service.yaml\" created\nINFO Kubernetes file \"mlbparks-service.yaml\" created\nINFO Kubernetes file \"mongodb-service.yaml\" created\nINFO Kubernetes file \"redis-master-service.yaml\" created\nINFO Kubernetes file \"redis-replica-service.yaml\" created\nINFO Kubernetes file \"frontend-deployment.yaml\" created\nINFO Kubernetes file \"mlbparks-deployment.yaml\" created\nINFO Kubernetes file \"mongodb-deployment.yaml\" created\nINFO Kubernetes file \"mongodb-claim0-persistentvolumeclaim.yaml\" created\nINFO Kubernetes file \"redis-master-deployment.yaml\" created\nINFO Kubernetes file \"redis-replica-deployment.yaml\" created\n\n$ ls\nmlbparks-deployment.yaml  mongodb-service.yaml                       redis-replica-service.jsonmlbparks-service.yaml\nfrontend-deployment.yaml  mongodb-claim0-persistentvolumeclaim.yaml  redis-master-service.yaml\nfrontend-service.yaml     mongodb-deployment.yaml                    redis-replica-deployment.yaml\nredis-master-deployment.yaml\n</code></pre> <p>When multiple docker-compose files are provided the configuration is merged. Any configuration that is common will be over ridden by subsequent file.</p>"},{"location":"03-Django-Rest-Api/user-guide/#openshift","title":"OpenShift","text":"<pre><code>$ kompose --provider openshift --file docker-voting.yml convert\nWARN [worker] Service cannot be created because of missing port.\nINFO OpenShift file \"vote-service.yaml\" created\nINFO OpenShift file \"db-service.yaml\" created\nINFO OpenShift file \"redis-service.yaml\" created\nINFO OpenShift file \"result-service.yaml\" created\nINFO OpenShift file \"vote-deploymentconfig.yaml\" created\nINFO OpenShift file \"vote-imagestream.yaml\" created\nINFO OpenShift file \"worker-deploymentconfig.yaml\" created\nINFO OpenShift file \"worker-imagestream.yaml\" created\nINFO OpenShift file \"db-deploymentconfig.yaml\" created\nINFO OpenShift file \"db-imagestream.yaml\" created\nINFO OpenShift file \"redis-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-imagestream.yaml\" created\nINFO OpenShift file \"result-deploymentconfig.yaml\" created\nINFO OpenShift file \"result-imagestream.yaml\" created\n</code></pre> <p>It also supports creating buildconfig for build directive in a service. By default, it uses the remote repository for the current git branch as the source repository, and the current branch as the source branch for the build. You can specify a different source repository and branch using <code>--build-repo</code> and <code>--build-branch</code> options respectively.</p> <pre><code>$ kompose --provider openshift --file buildconfig/docker-compose.yml convert\nWARN [foo] Service cannot be created because of missing port.\nINFO OpenShift Buildconfig using git@github.com:rtnpro/kompose.git::master as source.\nINFO OpenShift file \"foo-deploymentconfig.yaml\" created\nINFO OpenShift file \"foo-imagestream.yaml\" created\nINFO OpenShift file \"foo-buildconfig.yaml\" created\n</code></pre> <p>Note: If you are manually pushing the Openshift artifacts using <code>oc create -f</code>, you need to ensure that you push the imagestream artifact before the buildconfig artifact, to work around this Openshift issue: https://github.com/openshift/origin/issues/4518 .</p>"},{"location":"03-Django-Rest-Api/user-guide/#alternative-conversions","title":"Alternative Conversions","text":"<p>The default <code>kompose</code> transformation will generate Kubernetes Deployments and Services, in yaml format. You have alternative option to generate json with <code>-j</code>. Also, you can alternatively generate Replication Controllers objects, Daemon Sets, Statefulset or Helm charts.</p> <pre><code>$ kompose convert -j\nINFO Kubernetes file \"redis-svc.json\" created\nINFO Kubernetes file \"web-svc.json\" created\nINFO Kubernetes file \"redis-deployment.json\" created\nINFO Kubernetes file \"web-deployment.json\" created\n</code></pre> <p>The <code>*-deployment.json</code> files contain the Deployment objects.</p> <pre><code>$ kompose convert --controller replicationController\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"web-svc.yaml\" created\nINFO Kubernetes file \"redis-replicationcontroller.yaml\" created\nINFO Kubernetes file \"web-replicationcontroller.yaml\" created\n</code></pre> <p>The <code>*-replicationcontroller.yaml</code> files contain the Replication Controller objects. If you want to specify replicas (default is 1), use <code>--replicas</code> flag: <code>$ kompose convert --controller replicationController --replicas 3</code></p> <pre><code>$ kompose convert --controller daemonSet\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"web-svc.yaml\" created\nINFO Kubernetes file \"redis-daemonset.yaml\" created\nINFO Kubernetes file \"web-daemonset.yaml\" created\n</code></pre> <p>The <code>*-daemonset.yaml</code> files contain the Daemon Set objects</p> <pre><code>$ kompose convert --controller statefulset\nINFO Kubernetes file \"db-service.yaml\" created\nINFO Kubernetes file \"wordpress-service.yaml\" created\nINFO Kubernetes file \"db-statefulset.yaml\" created\nINFO Kubernetes file \"wordpress-statefulset.yaml\" created\n</code></pre> <p>The <code>*statefulset-.yaml</code> files contain the Statefulset objects.</p> <p>If you want to generate a Chart to be used with Helm simply do:</p> <pre><code>$ kompose convert -c\nINFO Kubernetes file \"web-svc.yaml\" created\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"web-deployment.yaml\" created\nINFO Kubernetes file \"redis-deployment.yaml\" created\nchart created in \"./docker-compose/\"\n\n$ tree docker-compose/\ndocker-compose\n\u251c\u2500\u2500 Chart.yaml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 templates\n    \u251c\u2500\u2500 redis-deployment.yaml\n    \u251c\u2500\u2500 redis-svc.yaml\n    \u251c\u2500\u2500 web-deployment.yaml\n    \u2514\u2500\u2500 web-svc.yaml\n</code></pre> <p>The chart structure is aimed at providing a skeleton for building your Helm charts. It's compatible with both Helm V2 and Helm V3.</p>"},{"location":"03-Django-Rest-Api/user-guide/#labels","title":"Labels","text":"<p><code>kompose</code> supports Kompose-specific labels within the <code>docker-compose.yml</code> file to explicitly define the generated resources' behavior upon conversion, like Service, PersistentVolumeClaim...</p> <p>The currently supported options are:</p> Key Value kompose.service.type nodeport / clusterip / loadbalancer / headless kompose.service.group name to group the containers contained in a single pod kompose.service.expose true / hostnames (separated by comma) kompose.service.nodeport.port port value (string) kompose.service.expose.tls-secret secret name kompose.service.expose.ingress-class-name ingress class name kompose.volume.size kubernetes supported volume size kompose.volume.storage-class-name kubernetes supported volume storageClassName kompose.volume.type use k8s volume type, eg \"configMap\", \"persistentVolumeClaim\", \"emptyDir\", \"hostPath\" kompose.controller.type deployment / daemonset / replicationcontroller / statefulset kompose.image-pull-policy kubernetes pods imagePullPolicy kompose.image-pull-secret kubernetes secret name for imagePullSecrets kompose.service.healthcheck.readiness.disable kubernetes readiness disable kompose.service.healthcheck.readiness.test kubernetes readiness exec command kompose.service.healthcheck.readiness.http_get_path kubernetes readiness httpGet path kompose.service.healthcheck.readiness.http_get_port kubernetes readiness httpGet port kompose.service.healthcheck.readiness.tcp_port kubernetes readiness tcpSocket port kompose.service.healthcheck.readiness.interval kubernetes readiness interval value kompose.service.healthcheck.readiness.timeout kubernetes readiness timeout value kompose.service.healthcheck.readiness.retries kubernetes readiness retries value kompose.service.healthcheck.readiness.start_period kubernetes readiness start_period kompose.service.healthcheck.liveness.http_get_path kubernetes liveness httpGet path kompose.service.healthcheck.liveness.http_get_port kubernetes liveness httpGet port kompose.service.healthcheck.liveness.tcp_port kubernetes liveness tcpSocket port kompose.service.external-traffic-policy 'cluster', 'local', '' kompose.security-context.fsgroup kubernetes pod security group fsgroup kompose.volume.sub-path kubernetes volume mount subpath <p>Note: <code>kompose.service.type</code> label should be defined with <code>ports</code> only (except for headless service), otherwise <code>kompose</code> will fail.</p> <ul> <li><code>kompose.service.type</code> defines the type of service to be created.</li> </ul> <p>For example:</p> <pre><code>version: \"2\"\nservices:\n  nginx:\n    image: nginx\n    dockerfile: foobar\n    build: ./foobar\n    cap_add:\n      - ALL\n    container_name: foobar\n    labels:\n      kompose.service.type: nodeport\n</code></pre> <ul> <li><code>kompose.service.group</code> defines the group of containers included in a single pod.</li> </ul> <p>For example:</p> <pre><code>version: \"3\"\n\nservices:\n  nginx:\n    image: nginx\n    depends_on:\n      - logs\n    labels:\n      - kompose.service.group=sidecar\n\n  logs:\n    image: busybox\n    command: [\"tail -f /var/log/nginx/access.log\"]\n    labels:\n      - kompose.service.group=sidecar\n</code></pre> <ul> <li><code>kompose.service.expose</code> defines if the service needs to be made accessible from outside the cluster or not. If the value is set to \"true\", the provider sets the endpoint automatically, and for any other value, the value is set as the hostname. If multiple ports are defined in a service, the first one is chosen to be the exposed.</li> <li>For the Kubernetes provider, an ingress resource is created, and it is assumed that an ingress controller has already been configured. If the value is set to a comma-separated list, multiple hostnames are supported. Hostname with the path is also supported.</li> <li>For the OpenShift provider, a route is created.</li> <li><code>kompose.service.nodeport.port</code> defines the port value when service type is <code>nodeport</code>, this label should only be set when the service only contains 1 port. Usually kubernetes define a port range for node port values, kompose will not validate this.</li> <li><code>kompose.service.expose.tls-secret</code> provides the name of the TLS secret to use with the Kubernetes ingress controller. This requires kompose.service.expose to be set.</li> <li><code>kompose.service.expose.ingress-class-name</code> provides the name of ingress class to use with the Kubernetes ingress controller. This requires kompose.service.</li> </ul> <p>For example:</p> <pre><code>version: \"2\"\nservices:\n  web:\n    image: tuna/docker-counter23\n    ports:\n     - \"5000:5000\"\n    links:\n     - redis\n    labels:\n      kompose.service.expose: \"counter.example.com,foobar.example.com\"\n      kompose.service.expose.tls-secret: \"example-secret\"\n      kompose.service.expose.ingress-class-name: \"nginx\"\n  redis:\n    image: redis:3.0\n    ports:\n     - \"6379\"\n</code></pre> <ul> <li><code>kompose.serviceaccount-name</code> defines the service account name to provide the credential info of the pod.</li> </ul> <p>For example:</p> <pre><code>version: '3.4'\nservices:\n  app:\n    image: python\n    labels:\n      kompose.serviceaccount-name: \"my-service\"\n</code></pre> <ul> <li><code>kompose.image-pull-secret</code> defines a kubernetes secret name for imagePullSecrets podspec field.   This secret will be used for pulling private images.   For example:</li> </ul> <pre><code>version: '2'\nservices:\n  tm-service:\n    image: premium/private-image\n    labels:\n      kompose.image-pull-secret: \"example-kubernetes-secret\"\n</code></pre> <ul> <li><code>kompose.volume.size</code> defines the requests storage's size in the PersistentVolumeClaim, or you can use the command line parameter <code>--pvc-request-size</code>.</li> <li>The priority follows label (kompose.volume.size) &gt; command parameter(--pvc-request-size) &gt; defaultSize (100Mi)</li> </ul> <p>For example:</p> <pre><code>version: '2'\nservices:\n  db:\n    image: postgres:10.1\n    labels:\n      kompose.volume.size: 1Gi\n    volumes:\n      - db-data:/var/lib/postgresql/data\n</code></pre> <ul> <li><code>kompose.volume.storage-class-name</code> defines the requests storage's class name in the PersistentVolumeClaim.</li> </ul> <p>For example:</p> <pre><code>version: '3'\nservices:\n  db:\n    image: postgres:10.1\n    labels:\n      kompose.volume.storage-class-name: custom-storage-class-name\n    volumes:\n      - db-data:/var/lib/postgresql/data\n</code></pre> <ul> <li><code>kompose.controller.type</code> defines which controller type should convert for this service</li> </ul> <p>For example:</p> <pre><code>web:\n  image: wordpress:4.5\n  ports:\n    - '80'\n  environment:\n    WORDPRESS_AUTH_KEY: changeme\n    WORDPRESS_SECURE_AUTH_KEY: changeme\n    WORDPRESS_LOGGED_IN_KEY: changeme\n    WORDPRESS_NONCE_KEY: changeme\n    WORDPRESS_AUTH_SALT: changeme\n    WORDPRESS_SECURE_AUTH_SALT: changeme\n    WORDPRESS_LOGGED_IN_SALT: changeme\n    WORDPRESS_NONCE_SALT: changeme\n    WORDPRESS_NONCE_AA: changeme\n  restart: always\n  links:\n    - 'db:mysql'\ndb:\n  image: mysql:5.7\n  environment:\n    MYSQL_ROOT_PASSWORD: password\n  restart: always\n  labels:\n    project.logs: /var/log/mysql\n    kompose.controller.type: daemonset\n</code></pre> <p>Service <code>web</code> will be converted to <code>Deployment</code> as default, service <code>db</code> will be converted to <code>DaemonSet</code> because of <code>kompose.controller.type</code> label.</p> <ul> <li><code>kompose.image-pull-policy</code> defines Kubernetes PodSpec imagePullPolicy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.</li> </ul> <p>For example:</p> <pre><code>version: '2'\nservices:\n  example-service:\n    image: example-image\n    labels:\n      kompose.image-pull-policy: \"Never\"\n</code></pre> <p>For example:</p> <pre><code>version: '2'\nservices:\n  example-service:\n    image: example-image\n    labels:\n      kompose.service.healthcheck.liveness.http_get_path: /health/ping\n      kompose.service.healthcheck.liveness.http_get_port: 8080\n    healthcheck:\n      interval: 10s\n      timeout: 10s\n      retries: 3\n      start_period: 30s\n</code></pre> <ul> <li><code>kompose.service.healthcheck.liveness</code> defines Kubernetes liveness HttpRequest, If you use healthcheck without liveness labels, have to define <code>test</code> in healcheck it's work to Kubernetes liveness command</li> </ul> <p>For example:</p> <pre><code>version: '2'\nservices:\n  example-service:\n    image: example-image\n    labels:\n      kompose.service.healthcheck.readiness.test: CMD curl -f \"http://localhost:8080/health/ping\"\n      kompose.service.healthcheck.readiness.interval: 10s\n      kompose.service.healthcheck.readiness.timeout: 10s\n      kompose.service.healthcheck.readiness.retries: 3\n      kompose.service.healthcheck.readiness.start_period: 30s\n</code></pre> <ul> <li> <p><code>kompose.service.healthcheck.readiness</code> defines Kubernetes readiness</p> </li> <li> <p><code>kompose.service.external-traffic-policy</code> defines Kubernetes Service external traffic policy..</p> </li> </ul> <p>For example:</p> <pre><code>version: \"3.3\"\n\nservices:\n  front-end:\n    image: gcr.io/google-samples/gb-frontend:v4\n    environment:\n      - GET_HOSTS_FROM=dns\n    ports:\n      - 80:80\n    labels:\n      kompose.service.expose: lb\n      kompose.service.external-traffic-policy: local\n      kompose.service.type: loadbalancer\n</code></pre> <ul> <li><code>kompose.security-context.fsgroup</code> defines Kubernetes Pod security context FsGroup..</li> </ul> <p>For example:</p> <pre><code>version: '3.8'\n\nservices:\n  pgadmin:\n    image: nginx\n    labels:\n      kompose.security-context.fsgroup: 1001\n</code></pre> <ul> <li><code>kompose.volume.sub-path</code> defines Kubernetes Container VolumeMounts Subpath.</li> </ul> <p>For example:</p> <pre><code>version: '3.8'\n\nservices:\n  pgadmin:\n    image: postgres\n    labels:\n      kompose.volume.sub-path: pg-data\n</code></pre>"},{"location":"03-Django-Rest-Api/user-guide/#restart","title":"Restart","text":"<p>If you want to create normal pods without controller you can use <code>restart</code> construct of docker-compose to define that. Follow table below to see what happens on the <code>restart</code> value.</p> <code>docker-compose</code> <code>restart</code> object created Pod <code>restartPolicy</code> <code>\"\"</code> controller object <code>Always</code> <code>always</code> controller object <code>Always</code> <code>unless-stopped</code> controller object <code>Always</code> <code>on-failure</code> Pod <code>OnFailure</code> <code>no</code> Pod <code>Never</code> <p>Note: controller object could be <code>deployment</code> or <code>replicationcontroller</code>, etc.</p> <p>For e.g. <code>pival</code> service will become pod down here. This container calculated value of <code>pi</code>.</p> <pre><code>version: '2'\n\nservices:\n  pival:\n    image: perl\n    command: [\"perl\",  \"-Mbignum=bpi\", \"-wle\", \"print bpi(2000)\"]\n    restart: \"on-failure\"\n</code></pre>"},{"location":"03-Django-Rest-Api/user-guide/#warning-about-deployment-configs","title":"Warning about Deployment Config's","text":"<p>If the Docker Compose file has a volume specified for a service, the Deployment (Kubernetes) or DeploymentConfig (OpenShift) strategy is changed to \"Recreate\" instead of \"RollingUpdate\" (default). This is done to avoid multiple instances of a service from accessing a volume at the same time.</p> <p>If the Docker Compose file has service name with <code>_</code> or <code>.</code> in it (eg.<code>web_service</code> or <code>web.service</code>), then it will be replaced by <code>-</code> and the service name will be renamed accordingly (eg.<code>web-service</code>). Kompose does this because \"Kubernetes\" doesn't allow <code>_</code> in object name.</p> <p>Please note that changing service name might break some <code>docker-compose</code> files.</p>"},{"location":"03-Django-Rest-Api/user-guide/#network-policies-generation","title":"Network policies generation","text":"<p>Network policies are not generated by default, because it's not mandatory to deploy your application. However, it's one of the best practices when it comes to deploy secure applications on top of Kubernetes. To generate network policies, all you need is to use the <code>--generate-network-policies</code> flag.</p>"},{"location":"03-Django-Rest-Api/user-guide/#build-and-push-image","title":"Build and push image","text":"<p>If the Docker Compose file has <code>build</code> or <code>build:context, build:dockerfile</code> keys, build will run when <code>--build</code> specified.</p> <p>And Image will push to docker.io (default) when <code>--push-image=true</code> specified.</p> <p>It is possible to push to custom registry by specify <code>--push-image-registry</code>, which will override the registry from image name.</p>"},{"location":"03-Django-Rest-Api/user-guide/#authentication-on-registry","title":"Authentication on registry","text":"<p>Kompose uses the docker authentication from file <code>$DOCKER_CONFIG/config.json</code>, <code>$HOME/.docker/config.json</code>, and <code>$HOME/.dockercfg</code> after <code>docker login</code>.</p> <p>This only works fine on Linux but macOS would fail when using <code>\"credsStore\": \"osxkeychain\"</code>.</p> <p>However, there is an approach to push successfully on macOS, by not using <code>osxkeychain</code> for <code>credsStore</code>. To disable <code>osxkeychain</code>:</p> <ul> <li>remove <code>credsStore</code> from <code>config.json</code> file, and <code>docker login</code> again.</li> <li>for some docker desktop versions, there is a setting <code>Securely store Docker logins in macOS keychain</code>, which should be unchecked. Then restart docker desktop if needed, and <code>docker login</code> again.</li> </ul> <p>Now <code>config.json</code> should contain base64 encoded passwords, then push image should succeed. Working, but not safe though! Use it at your risk.</p> <p>For Windows, there is also <code>credsStore</code> which is <code>wincred</code>. Technically it will fail on authentication as macOS does, but you can try the approach above like macOS too.</p>"},{"location":"03-Django-Rest-Api/user-guide/#custom-build-and-push","title":"Custom Build and Push","text":"<p>If you want to customize the build and push processes and use another containers solution than Docker, Kompose offers you the possibility to do that. You can use <code>--build-command</code> and <code>--push-command</code> flags to achieve that.</p> <p>e.g: <code>kompose -f convert --build-command 'whatever command --you-use' --push-command 'whatever command --you-use'</code></p>"},{"location":"template-content/konsole-pristine/","title":"Kompose - Convert your Docker Compose file to Kubernetes or OpenShift","text":"<p>An official Kubernetes project, located at github.com/kubernetes/kompose Go from Docker Compose to Kubernetes.</p> <p></p> <p>Kompose is a conversion tool for Docker Compose to container orchestrators such as Kubernetes (or OpenShift).</p> <pre><code>$ kompose convert -f docker-compose.yaml\n\n$ kubectl apply -f .\n\n$ kubectl get po\nNAME                            READY     STATUS              RESTARTS   AGE\nfrontend-591253677-5t038        1/1       Running             0          10s\nredis-master-2410703502-9hshf   1/1       Running             0          10s\nredis-replica-4049176185-hr1lr  1/1       Running             0          10s\n</code></pre> <p>Installation Guide</p>"},{"location":"template-content/konsole-pristine/#get-started-on-kubernetes-immediately","title":"Get started on Kubernetes immediately","text":"<p>So easy your human companion could do it too!</p> <p>Why do cats (and developers) like Kompose?</p> <p>Developers love to simplify their development environment with Docker Compose.</p> <p>With Kompose, you can now push the same file to a production container orchestrator!</p> <p>Getting Started</p>"},{"location":"template-content/konsole-pristine/#built-for-container-engineers","title":"Built for container engineers","text":"<p>Our conversions are not always 1-1 from Docker Compose to Kubernetes, but we will help get you 99% of the way there!</p>"},{"location":"template-content/konsole-pristine/#the-awesome-features","title":"The awesome features","text":"<ul> <li>Compatibility with multiple versions of Docker Compose</li> <li>A conversion matrix that outlines all compatible values and versions</li> <li>An in-depth user guide to use advanced features such as LoadBalancer, Service and TLS</li> <li>Labels that provide the extra 1% needed to get to 1-1 conversion</li> </ul> <p>User Guide</p>"},{"location":"template-content/konsole-pristine/developer-guides/conversion-detail-matrix/","title":"Conversion Matrix","text":"<ul> <li>TOC {:toc}</li> </ul> <p>This document outlines all possible conversion details regarding <code>docker-compose.yaml</code> values to Kubernetes / OpenShift artifacts.</p>"},{"location":"template-content/konsole-pristine/developer-guides/conversion-detail-matrix/#version-support","title":"Version Support","text":"<p>Under the hood, we're using compose-go, the reference library for parsing Compose files. We should be able to load all versions of Compose files. We're doing our best to keep it up to date as soon as possible in our releases to be compatible with the latest features defined in the Compose specification. If you absolutely need a feature we don't support yet, please open a PR!</p>"},{"location":"template-content/konsole-pristine/developer-guides/conversion-detail-matrix/#conversion-table","title":"Conversion Table","text":"<p>Glossary:</p> <ul> <li>\u2713: Converts</li> <li>-: Not in this Docker Compose Version</li> <li>n: Not yet implemented</li> <li>x: Not applicable / no 1-1 conversion</li> </ul> Keys V1 V2 V3 Kubernetes / OpenShift Notes build \u2713 \u2713 \u2713 Builds/Pushes to Docker repository. See user guide on build and push image build: context \u2713 \u2713 \u2713 build: dockerfile \u2713 \u2713 \u2713 build: args n n n build: cache_from - - n cap_add \u2713 \u2713 \u2713 Container.SecurityContext.Capabilities.Add cap_drop \u2713 \u2713 \u2713 Container.SecurityContext.Capabilities.Drop command \u2713 \u2713 \u2713 Container.Args configs n n \u2713 configs: short-syntax n n \u2713 Only create configMap configs: long-syntax n n \u2713 If target path is /, ignore this and only create configMap cgroup_parent x x x Not supported within Kubernetes. See issue https://github.com/kubernetes/kubernetes/issues/11986 container_name \u2713 \u2713 \u2713 Metadata.Name + Deployment.Spec.Containers.Name credential_spec x x x Only applicable to Windows containers deploy - - \u2713 deploy: mode - - \u2713 deploy: replicas - - \u2713 Deployment.Spec.Replicas / DeploymentConfig.Spec.Replicas deploy: placement - - \u2713 Affinity deploy: update_config - - \u2713 Workload.Spec.Strategy Deployment / DeploymentConfig deploy: resources - - \u2713 Containers.Resources.Limits.Memory / Containers.Resources.Limits.CPU Support for memory as well as cpu deploy: restart_policy - - \u2713 Pod generation This generated a Pod, see the user guide on restart deploy: labels - - \u2713 Workload.Metadata.Labels Only applied to workload resource devices x x x Not supported within Kubernetes, See issue https://github.com/kubernetes/kubernetes/issues/5607 depends_on x x x dns x x x Not used within Kubernetes. Kubernetes uses a managed DNS server dns_search x x x See <code>dns</code> key domainname \u2713 \u2713 \u2713 SubDomain tmpfs \u2713 \u2713 \u2713 Containers.Volumes.EmptyDir Creates emptyDirvolume with medium set to Memory &amp; mounts given directory inside container entrypoint \u2713 \u2713 \u2713 Container.Command env_file n n \u2713 environment \u2713 \u2713 \u2713 Container.Env expose \u2713 \u2713 \u2713 Service.Spec.Ports endpoint_mode n n \u2713 If endpoint_mode=vip, the created Service will be forced to set to NodePort type extends \u2713 \u2713 \u2713 Extends by utilizing the same image supplied external_links x x x Kubernetes uses a flat-structure for all containers and thus external_links does not have a 1-1 conversion extra_hosts n n n group_add \u2713 \u2713 \u2713 healthcheck - n \u2713 hostname \u2713 \u2713 \u2713 HostName image \u2713 \u2713 \u2713 Deployment.Spec.Containers.Image isolation x x x Not applicable as this applies to Windows with HyperV support labels \u2713 \u2713 \u2713 Metadata.Annotations links x x x All containers in the same pod are accessible in Kubernetes logging x x x Kubernetes has built-in logging support at the node-level network_mode x x x Kubernetes uses its own cluster networking networks \u2713 \u2713 \u2713 See <code>networks</code> key networks: aliases x x x See <code>networks</code> key networks: addresses x x x See <code>networks</code> key pid \u2713 \u2713 \u2713 HostPID ports \u2713 \u2713 \u2713 Service.Spec.Ports ports: short-syntax \u2713 \u2713 \u2713 Service.Spec.Ports ports: long-syntax - - \u2713 Service.Spec.Ports secrets - - \u2713 Secret External Secret is not Supported secrets: short-syntax - - \u2713 Secret External Secret is not Supported secrets: long-syntax - - \u2713 Secret External Secret is not Supported security_opt x x x Kubernetes uses its own container naming scheme stop_grace_period \u2713 \u2713 \u2713 TerminationGracePeriodSeconds stop_signal x x x Not supported within Kubernetes. See issue https://github.com/kubernetes/kubernetes/issues/30051 sysctls n n n ulimits x x x Not supported within Kubernetes. See issue https://github.com/kubernetes/kubernetes/issues/3595 userns_mode x x x Not supported within Kubernetes and ignored in Docker Compose Version 3 volumes \u2713 \u2713 \u2713 PersistentVolumeClaim Creates a PersistentVolumeClaim. Can only be created if there is already a PersistentVolume within the cluster volumes: short-syntax \u2713 \u2713 \u2713 PersistentVolumeClaim Creates a PersistentVolumeClaim. Can only be created if there is already a PersistentVolume within the cluster volumes: long-syntax - - \u2713 PersistentVolumeClaim Creates a PersistentVolumeClaim. Can only be created if there is already a PersistentVolume within the cluster restart \u2713 \u2713 \u2713 Volume x x x driver x x x driver_opts x x x external x x x labels x x x Network x x x driver x x x driver_opts x x x enable_ipv6 x x x ipam x x x internal x x x labels x x x external x x x"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/","title":"Development Guide","text":""},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#building-kompose","title":"Building Kompose","text":"<p>Read about building kompose here.</p>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#workflow","title":"Workflow","text":""},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#fork-the-main-repository","title":"Fork the main repository","text":"<ol> <li>Go to https://github.com/kubernetes/kompose</li> <li>Click the \"Fork\" button (at the top right)</li> </ol>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#clone-your-fork","title":"Clone your fork","text":"<p>The commands below require that you have <code>$GOPATH</code>. We highly recommended you put the Kompose code into your <code>$GOPATH</code>.</p> <pre><code>git clone https://github.com/$YOUR_GITHUB_USERNAME/kompose.git $GOPATH/src/github.com/kubernetes/kompose\ncd $GOPATH/src/github.com/kubernetes/kompose\ngit remote add upstream 'https://github.com/kubernetes/kompose'\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#create-a-branch-and-make-changes","title":"Create a branch and make changes","text":"<pre><code>git checkout -b myfeature\n# Make your code changes\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#keeping-your-development-fork-in-sync","title":"Keeping your development fork in sync","text":"<pre><code>git fetch upstream\ngit rebase upstream/main\n</code></pre> <p>Note: If you have write access to the main repository at github.com/kubernetes/kompose, you should modify your git configuration so that you can't accidentally push to upstream:</p> <pre><code>git remote set-url --push upstream no_push\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#committing-changes-to-your-fork","title":"Committing changes to your fork","text":"<pre><code>git commit\ngit push -f origin myfeature\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#creating-a-pull-request","title":"Creating a pull request","text":"<ol> <li>Visit https://github.com/$YOUR_GITHUB_USERNAME/kompose.git</li> <li>Click the \"Compare and pull request\" button next to your \"myfeature\" branch.</li> <li>Check out the pull request process for more details</li> </ol>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#go-modules-and-dependency-management","title":"Go Modules and dependency management","text":"<p>Kompose uses Go Modules to manage dependencies. If you want to introduce changes to dependencies, please ensure that <code>go.mod</code> and <code>go.sum</code> are updated properly.</p>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#updating-kubernetes-and-openshift","title":"Updating Kubernetes and OpenShift","text":"<p>Kubernetes version depends on what version is OpenShift using. OpenShift is using forked Kubernetes to carry some patches. Currently, it is not possible to use a different Kubernetes version from the version that OpenShift uses. (for more see comments in <code>go.mod</code>)</p>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#adding-cli-tests","title":"Adding CLI tests","text":"<p>Kompose CLI tests run <code>kompose convert</code> with docker-compose files, and cross-check the k8s and OpenShift artifacts generated with the template files.</p> <p>To generate CLI tests, please run <code>make gen-cmd</code>.</p>"},{"location":"template-content/konsole-pristine/developer-guides/development-guide/#ci","title":"CI","text":"<p>For Kompose, we use numerous CI's:</p> <ul> <li>TravisCI: Unit and CLI tests</li> <li>SemaphoreCI: Integration / cluster tests</li> <li>Fabric8CI: Secondary integration tests / future cluster tests</li> </ul>"},{"location":"template-content/konsole-pristine/developer-guides/getting-started-guide/","title":"Getting Started Guide","text":"<p>This is how you'll get started with Kompose!</p> <p></p> <p>There are three different guides depending on your container orchestrator as well as operating system.</p> <p>For beginners and the most compatibility, follow the Minikube and Kompose guide.</p>"},{"location":"template-content/konsole-pristine/developer-guides/getting-started-guide/#minikube-and-kompose","title":"Minikube and Kompose","text":"<p>In this guide, we'll deploy a sample <code>docker-compose.yaml</code> file to a Kubernetes cluster.</p> <p>Requirements:</p> <ul> <li>minikube</li> <li>kompose</li> </ul> <p>Start <code>minikube</code>:</p> <p>If you don't already have a Kubernetes cluster running, minikube is the best way to get started.</p> <pre><code>$ minikube start\nStarting local Kubernetes v1.7.5 cluster...\nStarting VM...\nGetting VM IP address...\nMoving files into cluster...\nSetting up certs...\nConnecting to cluster...\nSetting up kubeconfig...\nStarting cluster components...\nKubectl is now configured to use the cluster\n</code></pre> <p>Download an example Docker Compose file, or use your own:</p> <pre><code>wget https://raw.githubusercontent.com/kubernetes/kompose/main/examples/docker-compose.yaml\n</code></pre> <p>Convert your Docker Compose file to Kubernetes:</p> <p>Run <code>kompose convert</code> in the same directory as your <code>docker-compose.yaml</code> file.</p> <pre><code>$ kompose convert\nINFO Kubernetes file \"frontend-service.yaml\" created\nINFO Kubernetes file \"redis-master-service.yaml\" created\nINFO Kubernetes file \"redis-replica-service.yaml\" created\nINFO Kubernetes file \"frontend-deployment.yaml\" created\nINFO Kubernetes file \"redis-master-deployment.yaml\" created\nINFO Kubernetes file \"redis-replica-deployment.yaml\" created\n</code></pre> <p>Then you can use <code>kubectl apply</code> to create these resources in Kubernetes.</p> <p>Access the newly deployed service:</p> <p>Now that your service has been deployed, let's access it.</p> <p>If you're using <code>minikube</code> you may access it via the <code>minikube service</code> command.</p> <pre><code>$ minikube service frontend\n</code></pre> <p>Otherwise, use <code>kubectl</code> to see what IP the service is using:</p> <pre><code>$ kubectl describe svc frontend\nName:                   frontend\nNamespace:              default\nLabels:                 service=frontend\nSelector:               service=frontend\nType:                   LoadBalancer\nIP:                     10.0.0.183\nLoadBalancer Ingress:   123.45.67.89\nPort:                   80      80/TCP\nNodePort:               80      31144/TCP\nEndpoints:              172.17.0.4:80\nSession Affinity:       None\nNo events.\n</code></pre> <p>Note: If you're using a cloud provider, your IP will be listed next to <code>LoadBalancer Ingress</code>.</p> <p>If you have yet to expose your service (for example, within GCE), use the command:</p> <pre><code>kubectl expose deployment frontend --type=\"LoadBalancer\"\n</code></pre> <p>To check functionality, you may also <code>curl</code> the URL.</p> <pre><code>$ curl http://123.45.67.89\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/getting-started-guide/#minishift-and-kompose","title":"Minishift and Kompose","text":"<p>In this guide, we'll deploy a sample <code>docker-compose.yaml</code> file to an OpenShift cluster.</p> <p>Requirements:</p> <ul> <li>minishift</li> <li>kompose</li> <li>An OpenShift route created</li> </ul> <p>Note: The service will NOT be accessible until you create an OpenShift route with <code>oc expose</code>. You must also have a virtualization environment setup. By default, <code>minishift</code> uses KVM.</p> <p>Start <code>minishift</code>:</p> <p>Minishift is a tool that helps run OpenShift locally using a single-node cluster inside a VM. Similar to minikube.</p> <pre><code>$ minishift start\nStarting local OpenShift cluster using 'kvm' hypervisor...\n-- Checking OpenShift client ... OK\n-- Checking Docker client ... OK\n-- Checking Docker version ... OK\n-- Checking for existing OpenShift container ... OK\n...\n</code></pre> <p>Download an example Docker Compose file, or use your own:</p> <pre><code>wget https://raw.githubusercontent.com/kubernetes/kompose/main/examples/docker-compose.yaml\n</code></pre> <p>Convert your Docker Compose file to OpenShift:</p> <p>Run <code>kompose convert --provider=openshift</code> in the same directory as your <code>docker-compose.yaml</code> file.</p> <pre><code>$ kompose convert --provider=openshift\nINFO OpenShift file \"frontend-service.yaml\" created\nINFO OpenShift file \"redis-master-service.yaml\" created\nINFO OpenShift file \"redis-replica-service.yaml\" created\nINFO OpenShift file \"frontend-deploymentconfig.yaml\" created\nINFO OpenShift file \"frontend-imagestream.yaml\" created\nINFO OpenShift file \"redis-master-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-master-imagestream.yaml\" created\nINFO OpenShift file \"redis-replica-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-replica-imagestream.yaml\" created\n</code></pre> <p>Then you can use <code>kubectl apply</code> to create these resources in OpenShift cluster.</p> <p>Access the newly deployed service:</p> <p>After deployment, you must create an OpenShift route in order to access the service.</p> <p>If you're using <code>minishift</code>, you'll use a combination of <code>oc</code> and <code>minishift</code> commands to access the service.</p> <p>Create a route for the <code>frontend</code> service using <code>oc</code>:</p> <pre><code>$ oc expose service/frontend\nroute \"frontend\" exposed\n</code></pre> <p>Access the <code>frontend</code> service with <code>minishift</code>:</p> <pre><code>$ minishift openshift service frontend --namespace=myproject\nOpening the service myproject/frontend in the default browser...\n</code></pre> <p>You can also access the GUI interface of OpenShift for an overview of the deployed containers:</p> <pre><code>$ minishift console\nOpening the OpenShift Web console in the default browser...\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/getting-started-guide/#rhel-and-kompose","title":"RHEL and Kompose","text":"<p>In this guide, we'll deploy a sample <code>docker-compose.yaml</code> file using both RHEL (Red Hat Enterprise Linux) and OpenShift.</p> <p>Requirements:</p> <ul> <li>Red Hat Enterprise Linux 7.4</li> <li>Red Hat Development Suite</li> <li>Which includes:</li> <li>minishift</li> <li>kompose</li> </ul> <p>Note: A KVM hypervisor must be setup in order to correctly use <code>minishift</code> on RHEL. You can set it up via the CDK Documentation under \"Set up your virtualization environment\".</p> <p>Install Red Hat Development Suite:</p> <p>Before we are able to use both <code>minishift</code> and <code>kompose</code>, DevSuite must be installed. A more concise installation document is available.</p> <p>Change to root.</p> <pre><code>$ su -\n</code></pre> <p>Enable the Red Hat Developer Tools software repository.</p> <pre><code>$ subscription-manager repos --enable rhel-7-server-devtools-rpms\n$ subscription-manager repos --enable rhel-server-rhscl-7-rpms\n</code></pre> <p>Add the Red Hat Developer Tools key to your system.</p> <pre><code>$ cd /etc/pki/rpm-gpg\n$ wget -O RPM-GPG-KEY-redhat-devel https://www.redhat.com/security/data/a5787476.txt\n$ rpm --import RPM-GPG-KEY-redhat-devel\n</code></pre> <p>Install Red Hat Development Suite and Kompose.</p> <pre><code>$ yum install rh-devsuite kompose -y\n</code></pre> <p>Start <code>minishift</code>:</p> <p>Before we begin, we must do a few preliminary steps setting up <code>minishift</code>.</p> <pre><code>$ su -\n$ ln -s /var/lib/cdk-minishift-3.0.0/minishift /usr/bin/minishift\n$ minishift setup-cdk --force --default-vm-driver=\"kvm\"\n$ ln -s /home/$(whoami)/.minishift/cache/oc/v3.5.5.8/oc /usr/bin/oc\n</code></pre> <p>Now we may start <code>minishift</code>.</p> <pre><code>$ minishift start\nStarting local OpenShift cluster using 'kvm' hypervisor...\n-- Checking OpenShift client ... OK\n-- Checking Docker client ... OK\n-- Checking Docker version ... OK\n-- Checking for existing OpenShift container ... OK\n...\n</code></pre> <p>Download an example Docker Compose file, or use your own:</p> <pre><code>wget https://raw.githubusercontent.com/kubernetes/kompose/main/examples/docker-compose.yaml\n</code></pre> <p>Convert your Docker Compose file to OpenShift:</p> <p>Run <code>kompose convert --provider=openshift</code> in the same directory as your <code>docker-compose.yaml</code> file.</p> <pre><code>$ kompose convert --provider=openshift\nINFO OpenShift file \"frontend-service.yaml\" created\nINFO OpenShift file \"redis-master-service.yaml\" created\nINFO OpenShift file \"redis-replica-service.yaml\" created\nINFO OpenShift file \"frontend-deploymentconfig.yaml\" created\nINFO OpenShift file \"frontend-imagestream.yaml\" created\nINFO OpenShift file \"redis-master-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-master-imagestream.yaml\" created\nINFO OpenShift file \"redis-replica-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-replica-imagestream.yaml\" created\n</code></pre> <p>Then you can use <code>kubectl apply</code> to create these resources in OpenShift.</p> <p>Access the newly deployed service:</p> <p>After deployment, you must create an OpenShift route in order to access the service.</p> <p>If you're using <code>minishift</code>, you'll use a combination of <code>oc</code> and <code>minishift</code> commands to access the service.</p> <p>Create a route for the <code>frontend</code> service using <code>oc</code>:</p> <pre><code>$ oc expose service/frontend\nroute \"frontend\" exposed\n</code></pre> <p>Access the <code>frontend</code> service with <code>minishift</code>:</p> <pre><code>$ minishift openshift service frontend --namespace=myproject\nOpening the service myproject/frontend in the default browser...\n</code></pre> <p>You can also access the GUI interface of OpenShift for an overview of the deployed containers:</p> <pre><code>$ minishift console\nOpening the OpenShift Web console in the default browser...\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/how-to-article/","title":"Fabric8 Maven Plugin + Kompose:","text":"<p>Let's deploy a Springboot Java application with Docker Compose file using Fabric8 Maven Plugin to Kubernetes or OpenShift.</p>"},{"location":"template-content/konsole-pristine/developer-guides/how-to-article/#requirements","title":"Requirements","text":"<ul> <li>Linux or MacOS or Windows</li> <li>JDK 1.7+ - JDK Quick Installation Guide</li> <li>Maven 3.x+ - Maven Installation Guide</li> <li>Kompose - Kompose Installation Guide</li> </ul> <p>1. Clone the example project from GitHub</p> <pre><code>$ git clone https://github.com/piyush1594/kompose-maven-example.git\n</code></pre> <p>Change current directory to <code>kompose-maven-example</code> directory.</p> <pre><code>$ cd kompose-maven-example\n</code></pre> <p>2. Add Fabric8 Maven Plugin to your project</p> <pre><code>$ mvn io.fabric8:fabric8-maven-plugin:3.5.28:setup\n</code></pre> <p>Add the Fabric8 Maven Plugin configuration to <code>pom.xml</code> of project. <code>pom.xml</code> is manifest or deployment descriptor file of a maven project.</p> <p>3. Install Kompose through Maven</p> <pre><code>$ mvn fabric8:install\n</code></pre> <p>This command installs the <code>kompose</code> on the host.</p> <p>4. Configure Fabric8 Maven Plugin to use a Docker Compose file</p> <pre><code>&lt;plugin&gt;\n  &lt;groupId&gt;io.fabric8&lt;/groupId&gt;\n  &lt;artifactId&gt;fabric8-maven-plugin&lt;/artifactId&gt;\n  &lt;configuration&gt;\n    &lt;composeFile&gt;path for docker compose file&lt;/composeFile&gt;\n  &lt;/configuration&gt;\n  &lt;executions&gt;\n    &lt;execution&gt;\n      &lt;goals&gt;\n        &lt;goal&gt;resource&lt;/goal&gt;\n        &lt;goal&gt;build&lt;/goal&gt;\n      &lt;/goals&gt;\n    &lt;/execution&gt;\n  &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Add the <code>&lt;configuration&gt;</code> and <code>&lt;executions&gt;</code> sections to <code>pom.xml</code> as shown in above <code>pom.xml</code> snippet. Update the <code>&lt;composeFile&gt;</code> to provide the relative path of Docker Compose file from <code>pom.xml</code></p> <p>5. Deploy application on Kubernetes or OpenShift</p> <p>Make sure that Kubernetes/OpenShift cluster or Minikube/Minishift is running. In case, if anything of this is not running, you can run Minishift to test this application by using the following command.</p> <pre><code>$ minishift start\n</code></pre> <p>Below command deploys this application on Kubernetes or OpenShift.</p> <pre><code>$ mvn fabric8:deploy\n</code></pre> <p>Now that your service has been deployed, let's access it by querying <code>pod</code>, <code>service</code> from Kubernetes or OpenShift.</p> <pre><code>$ oc get pods\nNAME                                    READY     STATUS      RESTARTS   AGE\nspringboot-docker-compose-1-xl0vb       1/1       Running     0          5m\nspringboot-docker-compose-s2i-1-build   0/1       Completed   0          7m\n</code></pre> <pre><code>$ oc get svc\nNAME                        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE\nspringboot-docker-compose   172.30.205.137   &lt;none&gt;        8080/TCP   6m\n</code></pre> <p>Let's access the Springboot service.</p> <pre><code>$ minishift openshift service --in-browser springboot-docker-compose\nCreated the new window in existing browser session.\n</code></pre> <p>It will open your application endpoint in default browser.</p> <p></p>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/","title":"Konsole Installation Guide","text":"<p>We have multiple ways to install Kompose. Our preferred (and most up-to-date) method is downloading the binary from the latest GitHub release.</p> <p></p>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#download-github-releases","title":"Download GitHub Releases","text":"<p>Kompose is released via GitHub, you can see all current releases on the GitHub release page.</p>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#github-release-for-linux","title":"Github Release For Linux","text":"<pre><code>\ncurl -L https://github.com/kubernetes/kompose/releases/download/v1.30.0/kompose-linux-amd64 -o kompose\n\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#github-release-for-macos","title":"Github Release For macOS","text":"<pre><code>curl -L https://github.com/kubernetes/kompose/releases/download/v1.30.0/kompose-darwin-amd64 -o kompose\n\nchmod +x kompose\n\nsudo mv ./kompose /usr/local/bin/kompose\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#github-release-for-windows","title":"Github Release For Windows","text":"<p>Download from GitHub and add the binary to your PATH.</p>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#go","title":"Go","text":"<p>Installing using <code>go install</code> pulls from the main branch with the latest development changes.</p> <pre><code>go install github.com/kubernetes/kompose@latest\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#centos","title":"CentOS","text":"<p>Kompose is in EPEL CentOS repository. If you don't have EPEL repository already installed and enabled you can do it by running <code>sudo yum install epel-release</code></p> <p>If you have EPEL enabled in your system, you can install Kompose like any other package.</p> <pre><code>sudo yum -y install kompose\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#fedora","title":"Fedora","text":"<p>Kompose is in Fedora 24, 25 and 26 repositories. You can install it just like any other package.</p> <pre><code>sudo dnf -y install kompose\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#macos","title":"macOS","text":"<p>On macOS, you can install the latest release via Homebrew or MacPorts.</p> <pre><code>brew install kompose\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#windows","title":"Windows","text":"<p>Kompose can be installed via Chocolatey</p> <pre><code>choco install kubernetes-kompose\n</code></pre> <p>or using winget</p> <pre><code>winget install Kubernetes.kompose\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/installation-guide/#docker","title":"Docker","text":"<p>You can build an image from the official repo for Docker or Podman:</p> <pre><code>docker build -t kompose https://github.com/kubernetes/kompose.git\\#main\n</code></pre> <p>To run the built image against the current directory, run the following command:</p> <pre><code>docker run --rm -it -v $PWD:/opt kompose sh -c \"cd /opt &amp;&amp; kompose convert\"\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/software-architecture-guide/","title":"Architecture and Internal Design","text":"<ul> <li>TOC {:toc}</li> </ul> <p><code>kompose</code> has 3 stages: Loader, Transformer and Outputter. Each stage should have a well-defined interface, so it is easy to write a new Loader, Transformer, or Outputters and plug it in. Currently, only Loader and Transformer interfaces are defined.</p> <p></p>"},{"location":"template-content/konsole-pristine/developer-guides/software-architecture-guide/#loader","title":"Loader","text":"<p>The Loader reads the input file now <code>kompose</code> supports Docker Compose v1, v2 and converts it to KomposeObject.</p> <p>Loader is represented by a Loader interface:</p> <pre><code>type Loader interface {\n      LoadFile(file string) kobject.KomposeObject\n}\n</code></pre> <p>Every loader \u201cimplementation\u201d should be placed into <code>kompose/pkg/loader</code> (like compose). More input formats will be supported in the future. You can take a look for more details at:</p> <ul> <li>kompose/pkg/loader</li> <li>kompose/pkg/loader/compose</li> </ul>"},{"location":"template-content/konsole-pristine/developer-guides/software-architecture-guide/#komposeobject","title":"KomposeObject","text":"<p><code>KomposeObject</code> is Kompose internal representation of all containers loaded from input file. First version of <code>KomposeObject</code> looks like this (source: kobject.go):</p> <pre><code>// KomposeObject holds the generic struct of Kompose transformation\ntype KomposeObject struct {\n    ServiceConfigs map[string]ServiceConfig\n}\n\n// ServiceConfig holds the basic struct of a container\ntype ServiceConfig struct {\n    ContainerName string\n    Image         string\n    Environment   []EnvVar\n    Port          []Ports\n    Command       []string\n    WorkingDir    string\n    Args          []string\n    Volumes       []string\n    Network       []string\n    Labels        map[string]string\n    Annotations   map[string]string\n    CPUSet        string\n    CPUShares     int64\n    CPUQuota      int64\n    CapAdd        []string\n    CapDrop       []string\n    Entrypoint    []string\n    Expose        []string\n    Privileged    bool\n    Restart       string\n    User          string\n}\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/software-architecture-guide/#transformer","title":"Transformer","text":"<p>The Transformer takes KomposeObject and converts it to target/output format (currently, there are sets of Kubernetes/OpenShift objects). Similar to the <code>Loader</code>, Transformer is represented by a Transformer interface:</p> <pre><code>type Transformer interface {\n     Transform(kobject.KomposeObject, kobject.ConvertOptions) []runtime.Object\n}\n</code></pre> <p>If you wish to add more providers containing different kinds of objects, the Transformer would be the place to look into. Currently, Kompose supports Kubernetes (by default) and OpenShift providers. More details at:</p> <ul> <li>kompose/pkg/transformer</li> <li>kompose/pkg/transformer/Kubernetes</li> <li>kompose/pkg/transformer/openshift</li> </ul>"},{"location":"template-content/konsole-pristine/developer-guides/software-architecture-guide/#outputter","title":"Outputter","text":"<p>The Outputter takes the Transformer result and executes the given action. For example, action can display results to stdout or directly deploy artifacts to Kubernetes/OpenShift.</p>"},{"location":"template-content/konsole-pristine/developer-guides/software-licenses/","title":"Integrations","text":"<ul> <li>TOC {:toc}</li> </ul> <p>There are some projects out there known to use Kompose integrated in some form or another</p>"},{"location":"template-content/konsole-pristine/developer-guides/software-licenses/#kompose-ui-by-jad-chamoun-icann-and-joe-haddad-anghami","title":"Kompose UI by Jad Chamoun (ICANN) and Joe Haddad (Anghami)","text":"<p>Description: \"A web interface to convert Docker Compose files to Kubernetes YAML\"</p> <p>Link: https://github.com/JadCham/komposeui</p>"},{"location":"template-content/konsole-pristine/developer-guides/software-licenses/#kompose-docker-container-by-cloudfind","title":"Kompose Docker Container by Cloudfind","text":"<p>Description: \"A Docker container for the Kompose translator for docker-compose\"</p> <p>Link: https://github.com/cloudfind/kompose-docker</p>"},{"location":"template-content/konsole-pristine/developer-guides/software-licenses/#kpm-by-coreos","title":"KPM by CoreOS","text":"<p>Description: \"KPM is a tool to deploy and manage application stacks on Kubernetes\"</p> <p>Link: https://github.com/coreos/kpm</p>"},{"location":"template-content/konsole-pristine/developer-guides/software-licenses/#docker-image-for-adobe-enterprise-manager-by-adfinis-sygroup-ag","title":"Docker Image for Adobe Enterprise Manager by Adfinis SyGroup AG","text":"<p>Description: \"Docker Image for Adobe Enterprise Manager\"</p> <p>Link: https://github.com/adfinis-sygroup/aem-docker/tree/master</p>"},{"location":"template-content/konsole-pristine/developer-guides/software-licenses/#kompose-ansible-playbook-by-chris-houseknecht-red-hat","title":"Kompose Ansible Playbook by Chris Houseknecht (Red Hat)","text":"<p>Description: \"Download and unarchive the latest kompose release asset for your OS\"</p> <p>Link: https://github.com/chouseknecht/kompose-install-role</p>"},{"location":"template-content/konsole-pristine/developer-guides/software-licenses/#fabric8-maven-plugin-by-red-hat","title":"Fabric8 Maven Plugin by Red Hat","text":"<p>Description: \"Maven is one of the widely used build tools for Java applications. The Fabric8 Maven Plugin is a maven extension that simplifies the deployment of Java applications to Kubernetes or OpenShift clusters. The main task of this plugin is to build Docker images, generate Kubernetes or OpenShift resource descriptors and run/deploy the application on Kubernetes or OpenShift cluster. The plugin has a wide range of configuration options. Docker Compose is one of the options to bring up deployments on Kubernetes or OpenShift clusters. Technically, Fabric8 Maven Plugin processes the external docker-compose.yml file and generates Kubernetes or OpenShift resources via Kompose.\"</p> <p>Links:</p> <ul> <li>Quickstart</li> <li>Documentation</li> </ul>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/","title":"User Guide","text":"<p>Kompose has support for two providers: OpenShift and Kubernetes.</p> <p></p> <p>You can choose a targeted provider using global option <code>--provider</code>. If no provider is specified, Kubernetes is set by default.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#kompose-convert","title":"Kompose Convert","text":"<p>Kompose supports conversion of V1, V2, and V3 Docker Compose files into Kubernetes and OpenShift objects.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#kubernetes","title":"Kubernetes","text":"<pre><code>$ kompose --file docker-voting.yml convert\nWARN Unsupported key networks - ignoring\nWARN Unsupported key build - ignoring\nINFO Kubernetes file \"worker-svc.yaml\" created\nINFO Kubernetes file \"db-svc.yaml\" created\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"result-svc.yaml\" created\nINFO Kubernetes file \"vote-svc.yaml\" created\nINFO Kubernetes file \"redis-deployment.yaml\" created\nINFO Kubernetes file \"result-deployment.yaml\" created\nINFO Kubernetes file \"vote-deployment.yaml\" created\nINFO Kubernetes file \"worker-deployment.yaml\" created\nINFO Kubernetes file \"db-deployment.yaml\" created\n\n$ ls\ndb-deployment.yaml  docker-compose.yml         docker-gitlab.yml  redis-deployment.yaml  result-deployment.yaml  vote-deployment.yaml  worker-deployment.yaml\ndb-svc.yaml         docker-voting.yml          redis-svc.yaml     result-svc.yaml        vote-svc.yaml           worker-svc.yaml\n</code></pre> <p>You can also provide multiple docker-compose files at the same time:</p> <pre><code>$ kompose -f docker-compose.yml -f docker-guestbook.yml convert\nINFO Kubernetes file \"frontend-service.yaml\" created\nINFO Kubernetes file \"mlbparks-service.yaml\" created\nINFO Kubernetes file \"mongodb-service.yaml\" created\nINFO Kubernetes file \"redis-master-service.yaml\" created\nINFO Kubernetes file \"redis-replica-service.yaml\" created\nINFO Kubernetes file \"frontend-deployment.yaml\" created\nINFO Kubernetes file \"mlbparks-deployment.yaml\" created\nINFO Kubernetes file \"mongodb-deployment.yaml\" created\nINFO Kubernetes file \"mongodb-claim0-persistentvolumeclaim.yaml\" created\nINFO Kubernetes file \"redis-master-deployment.yaml\" created\nINFO Kubernetes file \"redis-replica-deployment.yaml\" created\n\n$ ls\nmlbparks-deployment.yaml  mongodb-service.yaml                       redis-replica-service.jsonmlbparks-service.yaml\nfrontend-deployment.yaml  mongodb-claim0-persistentvolumeclaim.yaml  redis-master-service.yaml\nfrontend-service.yaml     mongodb-deployment.yaml                    redis-replica-deployment.yaml\nredis-master-deployment.yaml\n</code></pre> <p>When multiple docker-compose files are provided the configuration is merged. Any configuration that is common will be over ridden by subsequent file.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#openshift","title":"OpenShift","text":"<pre><code>$ kompose --provider openshift --file docker-voting.yml convert\nWARN [worker] Service cannot be created because of missing port.\nINFO OpenShift file \"vote-service.yaml\" created\nINFO OpenShift file \"db-service.yaml\" created\nINFO OpenShift file \"redis-service.yaml\" created\nINFO OpenShift file \"result-service.yaml\" created\nINFO OpenShift file \"vote-deploymentconfig.yaml\" created\nINFO OpenShift file \"vote-imagestream.yaml\" created\nINFO OpenShift file \"worker-deploymentconfig.yaml\" created\nINFO OpenShift file \"worker-imagestream.yaml\" created\nINFO OpenShift file \"db-deploymentconfig.yaml\" created\nINFO OpenShift file \"db-imagestream.yaml\" created\nINFO OpenShift file \"redis-deploymentconfig.yaml\" created\nINFO OpenShift file \"redis-imagestream.yaml\" created\nINFO OpenShift file \"result-deploymentconfig.yaml\" created\nINFO OpenShift file \"result-imagestream.yaml\" created\n</code></pre> <p>It also supports creating buildconfig for build directive in a service. By default, it uses the remote repository for the current git branch as the source repository, and the current branch as the source branch for the build. You can specify a different source repository and branch using <code>--build-repo</code> and <code>--build-branch</code> options respectively.</p> <pre><code>$ kompose --provider openshift --file buildconfig/docker-compose.yml convert\nWARN [foo] Service cannot be created because of missing port.\nINFO OpenShift Buildconfig using git@github.com:rtnpro/kompose.git::master as source.\nINFO OpenShift file \"foo-deploymentconfig.yaml\" created\nINFO OpenShift file \"foo-imagestream.yaml\" created\nINFO OpenShift file \"foo-buildconfig.yaml\" created\n</code></pre> <p>Note: If you are manually pushing the Openshift artifacts using <code>oc create -f</code>, you need to ensure that you push the imagestream artifact before the buildconfig artifact, to work around this Openshift issue: https://github.com/openshift/origin/issues/4518 .</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#alternative-conversions","title":"Alternative Conversions","text":"<p>The default <code>kompose</code> transformation will generate Kubernetes Deployments and Services, in yaml format. You have alternative option to generate json with <code>-j</code>. Also, you can alternatively generate Replication Controllers objects, Daemon Sets, Statefulset or Helm charts.</p> <pre><code>$ kompose convert -j\nINFO Kubernetes file \"redis-svc.json\" created\nINFO Kubernetes file \"web-svc.json\" created\nINFO Kubernetes file \"redis-deployment.json\" created\nINFO Kubernetes file \"web-deployment.json\" created\n</code></pre> <p>The <code>*-deployment.json</code> files contain the Deployment objects.</p> <pre><code>$ kompose convert --controller replicationController\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"web-svc.yaml\" created\nINFO Kubernetes file \"redis-replicationcontroller.yaml\" created\nINFO Kubernetes file \"web-replicationcontroller.yaml\" created\n</code></pre> <p>The <code>*-replicationcontroller.yaml</code> files contain the Replication Controller objects. If you want to specify replicas (default is 1), use <code>--replicas</code> flag: <code>$ kompose convert --controller replicationController --replicas 3</code></p> <pre><code>$ kompose convert --controller daemonSet\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"web-svc.yaml\" created\nINFO Kubernetes file \"redis-daemonset.yaml\" created\nINFO Kubernetes file \"web-daemonset.yaml\" created\n</code></pre> <p>The <code>*-daemonset.yaml</code> files contain the Daemon Set objects</p> <pre><code>$ kompose convert --controller statefulset\nINFO Kubernetes file \"db-service.yaml\" created\nINFO Kubernetes file \"wordpress-service.yaml\" created\nINFO Kubernetes file \"db-statefulset.yaml\" created\nINFO Kubernetes file \"wordpress-statefulset.yaml\" created\n</code></pre> <p>The <code>*statefulset-.yaml</code> files contain the Statefulset objects.</p> <p>If you want to generate a Chart to be used with Helm simply do:</p> <pre><code>$ kompose convert -c\nINFO Kubernetes file \"web-svc.yaml\" created\nINFO Kubernetes file \"redis-svc.yaml\" created\nINFO Kubernetes file \"web-deployment.yaml\" created\nINFO Kubernetes file \"redis-deployment.yaml\" created\nchart created in \"./docker-compose/\"\n\n$ tree docker-compose/\ndocker-compose\n\u251c\u2500\u2500 Chart.yaml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 templates\n    \u251c\u2500\u2500 redis-deployment.yaml\n    \u251c\u2500\u2500 redis-svc.yaml\n    \u251c\u2500\u2500 web-deployment.yaml\n    \u2514\u2500\u2500 web-svc.yaml\n</code></pre> <p>The chart structure is aimed at providing a skeleton for building your Helm charts. It's compatible with both Helm V2 and Helm V3.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#labels","title":"Labels","text":"<p><code>kompose</code> supports Kompose-specific labels within the <code>docker-compose.yml</code> file to explicitly define the generated resources' behavior upon conversion, like Service, PersistentVolumeClaim...</p> <p>The currently supported options are:</p> Key Value kompose.service.type nodeport / clusterip / loadbalancer / headless kompose.service.group name to group the containers contained in a single pod kompose.service.expose true / hostnames (separated by comma) kompose.service.nodeport.port port value (string) kompose.service.expose.tls-secret secret name kompose.service.expose.ingress-class-name ingress class name kompose.volume.size kubernetes supported volume size kompose.volume.storage-class-name kubernetes supported volume storageClassName kompose.volume.type use k8s volume type, eg \"configMap\", \"persistentVolumeClaim\", \"emptyDir\", \"hostPath\" kompose.controller.type deployment / daemonset / replicationcontroller / statefulset kompose.image-pull-policy kubernetes pods imagePullPolicy kompose.image-pull-secret kubernetes secret name for imagePullSecrets kompose.service.healthcheck.readiness.disable kubernetes readiness disable kompose.service.healthcheck.readiness.test kubernetes readiness exec command kompose.service.healthcheck.readiness.http_get_path kubernetes readiness httpGet path kompose.service.healthcheck.readiness.http_get_port kubernetes readiness httpGet port kompose.service.healthcheck.readiness.tcp_port kubernetes readiness tcpSocket port kompose.service.healthcheck.readiness.interval kubernetes readiness interval value kompose.service.healthcheck.readiness.timeout kubernetes readiness timeout value kompose.service.healthcheck.readiness.retries kubernetes readiness retries value kompose.service.healthcheck.readiness.start_period kubernetes readiness start_period kompose.service.healthcheck.liveness.http_get_path kubernetes liveness httpGet path kompose.service.healthcheck.liveness.http_get_port kubernetes liveness httpGet port kompose.service.healthcheck.liveness.tcp_port kubernetes liveness tcpSocket port kompose.service.external-traffic-policy 'cluster', 'local', '' kompose.security-context.fsgroup kubernetes pod security group fsgroup kompose.volume.sub-path kubernetes volume mount subpath <p>Note: <code>kompose.service.type</code> label should be defined with <code>ports</code> only (except for headless service), otherwise <code>kompose</code> will fail.</p> <ul> <li><code>kompose.service.type</code> defines the type of service to be created.</li> </ul> <p>For example:</p> <pre><code>version: \"2\"\nservices:\n  nginx:\n    image: nginx\n    dockerfile: foobar\n    build: ./foobar\n    cap_add:\n      - ALL\n    container_name: foobar\n    labels:\n      kompose.service.type: nodeport\n</code></pre> <ul> <li><code>kompose.service.group</code> defines the group of containers included in a single pod.</li> </ul> <p>For example:</p> <pre><code>version: \"3\"\n\nservices:\n  nginx:\n    image: nginx\n    depends_on:\n      - logs\n    labels:\n      - kompose.service.group=sidecar\n\n  logs:\n    image: busybox\n    command: [\"tail -f /var/log/nginx/access.log\"]\n    labels:\n      - kompose.service.group=sidecar\n</code></pre> <ul> <li><code>kompose.service.expose</code> defines if the service needs to be made accessible from outside the cluster or not. If the value is set to \"true\", the provider sets the endpoint automatically, and for any other value, the value is set as the hostname. If multiple ports are defined in a service, the first one is chosen to be the exposed.</li> <li>For the Kubernetes provider, an ingress resource is created, and it is assumed that an ingress controller has already been configured. If the value is set to a comma-separated list, multiple hostnames are supported. Hostname with the path is also supported.</li> <li>For the OpenShift provider, a route is created.</li> <li><code>kompose.service.nodeport.port</code> defines the port value when service type is <code>nodeport</code>, this label should only be set when the service only contains 1 port. Usually kubernetes define a port range for node port values, kompose will not validate this.</li> <li><code>kompose.service.expose.tls-secret</code> provides the name of the TLS secret to use with the Kubernetes ingress controller. This requires kompose.service.expose to be set.</li> <li><code>kompose.service.expose.ingress-class-name</code> provides the name of ingress class to use with the Kubernetes ingress controller. This requires kompose.service.</li> </ul> <p>For example:</p> <pre><code>version: \"2\"\nservices:\n  web:\n    image: tuna/docker-counter23\n    ports:\n     - \"5000:5000\"\n    links:\n     - redis\n    labels:\n      kompose.service.expose: \"counter.example.com,foobar.example.com\"\n      kompose.service.expose.tls-secret: \"example-secret\"\n      kompose.service.expose.ingress-class-name: \"nginx\"\n  redis:\n    image: redis:3.0\n    ports:\n     - \"6379\"\n</code></pre> <ul> <li><code>kompose.serviceaccount-name</code> defines the service account name to provide the credential info of the pod.</li> </ul> <p>For example:</p> <pre><code>version: '3.4'\nservices:\n  app:\n    image: python\n    labels:\n      kompose.serviceaccount-name: \"my-service\"\n</code></pre> <ul> <li><code>kompose.image-pull-secret</code> defines a kubernetes secret name for imagePullSecrets podspec field.   This secret will be used for pulling private images.   For example:</li> </ul> <pre><code>version: '2'\nservices:\n  tm-service:\n    image: premium/private-image\n    labels:\n      kompose.image-pull-secret: \"example-kubernetes-secret\"\n</code></pre> <ul> <li><code>kompose.volume.size</code> defines the requests storage's size in the PersistentVolumeClaim, or you can use the command line parameter <code>--pvc-request-size</code>.</li> <li>The priority follows label (kompose.volume.size) &gt; command parameter(--pvc-request-size) &gt; defaultSize (100Mi)</li> </ul> <p>For example:</p> <pre><code>version: '2'\nservices:\n  db:\n    image: postgres:10.1\n    labels:\n      kompose.volume.size: 1Gi\n    volumes:\n      - db-data:/var/lib/postgresql/data\n</code></pre> <ul> <li><code>kompose.volume.storage-class-name</code> defines the requests storage's class name in the PersistentVolumeClaim.</li> </ul> <p>For example:</p> <pre><code>version: '3'\nservices:\n  db:\n    image: postgres:10.1\n    labels:\n      kompose.volume.storage-class-name: custom-storage-class-name\n    volumes:\n      - db-data:/var/lib/postgresql/data\n</code></pre> <ul> <li><code>kompose.controller.type</code> defines which controller type should convert for this service</li> </ul> <p>For example:</p> <pre><code>web:\n  image: wordpress:4.5\n  ports:\n    - '80'\n  environment:\n    WORDPRESS_AUTH_KEY: changeme\n    WORDPRESS_SECURE_AUTH_KEY: changeme\n    WORDPRESS_LOGGED_IN_KEY: changeme\n    WORDPRESS_NONCE_KEY: changeme\n    WORDPRESS_AUTH_SALT: changeme\n    WORDPRESS_SECURE_AUTH_SALT: changeme\n    WORDPRESS_LOGGED_IN_SALT: changeme\n    WORDPRESS_NONCE_SALT: changeme\n    WORDPRESS_NONCE_AA: changeme\n  restart: always\n  links:\n    - 'db:mysql'\ndb:\n  image: mysql:5.7\n  environment:\n    MYSQL_ROOT_PASSWORD: password\n  restart: always\n  labels:\n    project.logs: /var/log/mysql\n    kompose.controller.type: daemonset\n</code></pre> <p>Service <code>web</code> will be converted to <code>Deployment</code> as default, service <code>db</code> will be converted to <code>DaemonSet</code> because of <code>kompose.controller.type</code> label.</p> <ul> <li><code>kompose.image-pull-policy</code> defines Kubernetes PodSpec imagePullPolicy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.</li> </ul> <p>For example:</p> <pre><code>version: '2'\nservices:\n  example-service:\n    image: example-image\n    labels:\n      kompose.image-pull-policy: \"Never\"\n</code></pre> <p>For example:</p> <pre><code>version: '2'\nservices:\n  example-service:\n    image: example-image\n    labels:\n      kompose.service.healthcheck.liveness.http_get_path: /health/ping\n      kompose.service.healthcheck.liveness.http_get_port: 8080\n    healthcheck:\n      interval: 10s\n      timeout: 10s\n      retries: 3\n      start_period: 30s\n</code></pre> <ul> <li><code>kompose.service.healthcheck.liveness</code> defines Kubernetes liveness HttpRequest, If you use healthcheck without liveness labels, have to define <code>test</code> in healcheck it's work to Kubernetes liveness command</li> </ul> <p>For example:</p> <pre><code>version: '2'\nservices:\n  example-service:\n    image: example-image\n    labels:\n      kompose.service.healthcheck.readiness.test: CMD curl -f \"http://localhost:8080/health/ping\"\n      kompose.service.healthcheck.readiness.interval: 10s\n      kompose.service.healthcheck.readiness.timeout: 10s\n      kompose.service.healthcheck.readiness.retries: 3\n      kompose.service.healthcheck.readiness.start_period: 30s\n</code></pre> <ul> <li> <p><code>kompose.service.healthcheck.readiness</code> defines Kubernetes readiness</p> </li> <li> <p><code>kompose.service.external-traffic-policy</code> defines Kubernetes Service external traffic policy..</p> </li> </ul> <p>For example:</p> <pre><code>version: \"3.3\"\n\nservices:\n  front-end:\n    image: gcr.io/google-samples/gb-frontend:v4\n    environment:\n      - GET_HOSTS_FROM=dns\n    ports:\n      - 80:80\n    labels:\n      kompose.service.expose: lb\n      kompose.service.external-traffic-policy: local\n      kompose.service.type: loadbalancer\n</code></pre> <ul> <li><code>kompose.security-context.fsgroup</code> defines Kubernetes Pod security context FsGroup..</li> </ul> <p>For example:</p> <pre><code>version: '3.8'\n\nservices:\n  pgadmin:\n    image: nginx\n    labels:\n      kompose.security-context.fsgroup: 1001\n</code></pre> <ul> <li><code>kompose.volume.sub-path</code> defines Kubernetes Container VolumeMounts Subpath.</li> </ul> <p>For example:</p> <pre><code>version: '3.8'\n\nservices:\n  pgadmin:\n    image: postgres\n    labels:\n      kompose.volume.sub-path: pg-data\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#restart","title":"Restart","text":"<p>If you want to create normal pods without controller you can use <code>restart</code> construct of docker-compose to define that. Follow table below to see what happens on the <code>restart</code> value.</p> <code>docker-compose</code> <code>restart</code> object created Pod <code>restartPolicy</code> <code>\"\"</code> controller object <code>Always</code> <code>always</code> controller object <code>Always</code> <code>unless-stopped</code> controller object <code>Always</code> <code>on-failure</code> Pod <code>OnFailure</code> <code>no</code> Pod <code>Never</code> <p>Note: controller object could be <code>deployment</code> or <code>replicationcontroller</code>, etc.</p> <p>For e.g. <code>pival</code> service will become pod down here. This container calculated value of <code>pi</code>.</p> <pre><code>version: '2'\n\nservices:\n  pival:\n    image: perl\n    command: [\"perl\",  \"-Mbignum=bpi\", \"-wle\", \"print bpi(2000)\"]\n    restart: \"on-failure\"\n</code></pre>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#warning-about-deployment-configs","title":"Warning about Deployment Config's","text":"<p>If the Docker Compose file has a volume specified for a service, the Deployment (Kubernetes) or DeploymentConfig (OpenShift) strategy is changed to \"Recreate\" instead of \"RollingUpdate\" (default). This is done to avoid multiple instances of a service from accessing a volume at the same time.</p> <p>If the Docker Compose file has service name with <code>_</code> or <code>.</code> in it (eg.<code>web_service</code> or <code>web.service</code>), then it will be replaced by <code>-</code> and the service name will be renamed accordingly (eg.<code>web-service</code>). Kompose does this because \"Kubernetes\" doesn't allow <code>_</code> in object name.</p> <p>Please note that changing service name might break some <code>docker-compose</code> files.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#network-policies-generation","title":"Network policies generation","text":"<p>Network policies are not generated by default, because it's not mandatory to deploy your application. However, it's one of the best practices when it comes to deploy secure applications on top of Kubernetes. To generate network policies, all you need is to use the <code>--generate-network-policies</code> flag.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#build-and-push-image","title":"Build and push image","text":"<p>If the Docker Compose file has <code>build</code> or <code>build:context, build:dockerfile</code> keys, build will run when <code>--build</code> specified.</p> <p>And Image will push to docker.io (default) when <code>--push-image=true</code> specified.</p> <p>It is possible to push to custom registry by specify <code>--push-image-registry</code>, which will override the registry from image name.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#authentication-on-registry","title":"Authentication on registry","text":"<p>Kompose uses the docker authentication from file <code>$DOCKER_CONFIG/config.json</code>, <code>$HOME/.docker/config.json</code>, and <code>$HOME/.dockercfg</code> after <code>docker login</code>.</p> <p>This only works fine on Linux but macOS would fail when using <code>\"credsStore\": \"osxkeychain\"</code>.</p> <p>However, there is an approach to push successfully on macOS, by not using <code>osxkeychain</code> for <code>credsStore</code>. To disable <code>osxkeychain</code>:</p> <ul> <li>remove <code>credsStore</code> from <code>config.json</code> file, and <code>docker login</code> again.</li> <li>for some docker desktop versions, there is a setting <code>Securely store Docker logins in macOS keychain</code>, which should be unchecked. Then restart docker desktop if needed, and <code>docker login</code> again.</li> </ul> <p>Now <code>config.json</code> should contain base64 encoded passwords, then push image should succeed. Working, but not safe though! Use it at your risk.</p> <p>For Windows, there is also <code>credsStore</code> which is <code>wincred</code>. Technically it will fail on authentication as macOS does, but you can try the approach above like macOS too.</p>"},{"location":"template-content/konsole-pristine/developer-guides/user-guide/#custom-build-and-push","title":"Custom Build and Push","text":"<p>If you want to customize the build and push processes and use another containers solution than Docker, Kompose offers you the possibility to do that. You can use <code>--build-command</code> and <code>--push-command</code> flags to achieve that.</p> <p>e.g: <code>kompose -f convert --build-command 'whatever command --you-use' --push-command 'whatever command --you-use'</code></p>"},{"location":"template-content/konsole-pristine/images-pictures/readme/","title":"Images &amp; Pictures Home","text":""},{"location":"template-content/konsole-pristine/project-management/project-management-home/","title":"project-management-home.md","text":""},{"location":"template-content/project-management/board/","title":"Board","text":"BACKLOG TO-DO IN-PROGRESS COMPLETED backlog completed in-progress to-do"},{"location":"template-content/project-management/eisenhower-matrix/","title":"Eisenhower Priority Matrix","text":"<p>Ref: https://todoist.com/productivity-methods/eisenhower-matrix</p> URGENT NOT URGENT IMPORTANT DO IT :<code>Immediate Deadlines</code> SCHEDULE IT :<code>Future Deadlines</code> NOT IMPORTANT DELEGATE IT :<code>You Are Not Required</code> DELETE IT :<code>Distraction, No Real Value</code>"},{"location":"template-content/project-management/gantt-chart/","title":"Gantt chart","text":"<pre><code>gantt\n    dateFormat  MM-DD\n    title       Example Gantt Chart\n\n    section Office Furniture\n        Research New Furniture  :done, 05-09, 3d\n                Order and Purchase Furniture  :crit, 05-18, 1d\n        Furniture Delivered to Office   : a1, 06-06, 2d\n        Distribute Furniture    :a2, after a1, 5d\n        Treat Furniture with Scotchgard :after a2, 3d\n\n    section Computer Upgrades\n        Research New Computers  :done, 05-09, 3d\n                Order and Purchase Computers  :crit, 05-18, 1d\n        Computers Delivered to Office   : a1, 06-06, 2d\n        Install Computers   :a2, after a1, 3d\n        Image and Update Computers  :after a2, 5d\n</code></pre>"},{"location":"template-content/project-management/instruction-document/","title":"Document Title","text":"<p>The document title should focus on the general content of the document. For example: \"Creating User Accounts in LDAP\". Provide a summary of the overall document content just after the title.</p>"},{"location":"template-content/project-management/instruction-document/#document-section","title":"Document Section","text":"<p>The document should be broken up into logical sections. Each section should then contain step-by-step or checklist instructions.</p> <p>For example, one section may be called \"Adding a New User\"</p>"},{"location":"template-content/project-management/instruction-document/#step-by-step-or-checklist-subsection","title":"Step-By-Step or Checklist Subsection","text":"<p>Each section should contain step-by-step instructions and/or a checklist of how to perform each action under the appropriate section. Include examples and images as needed.</p> <ol> <li>Verify user names meet convention requirements (1).</li> <li>From the command prompt, add the user to Ubuntu OpenLDAP Server: </li> </ol> <p><code>sudo ldapadduser eggsham domainname</code></p> <ul> <li>[ ] User added to Ubuntu OpenLDAP Server</li> </ul> <p>Add visual aids if necessary.</p> <pre><code>flowchart LR\n    A[\"Nightly Scheduled Task at 5:30am\"] --&gt; B{Test for New Input Files};\n    B ----&gt;|\"Input Files Do NOT Exist\"| E[End];\n    B --&gt;|\"Input Files Exist\"| C{\"Import Data from Files\"};\n    C ----&gt;|\"No New Data\"| D[\"Email and End\"];\n    C ----&gt;|\"New Data\"| F[\"Create Accounts and Email\"];\n</code></pre>"},{"location":"template-content/project-management/instruction-document/#reference","title":"Reference","text":"<p>The reference area should be used to add any additional information or instructions on how to deal with more specific circumstances, and/or to reference any external sources of information.</p> <p>(1) Section Title: Subtitle - Do not include hyphens (-) in user account names.</p> <p>\"OpenLDAP Server: User and Group Management.\" Ubuntu, 8 Nov. 2016, https://help.ubuntu.com/lts/serverguide/openldap-server.html.</p>"},{"location":"template-content/project-management/milestone-chart/","title":"Milestone Chart","text":"Milestone Scheduled Completion Actual Completion"},{"location":"template-content/project-management/project-overview/","title":"Project Overview","text":""},{"location":"template-content/project-management/project-overview/#defining-the-project","title":"Defining the Project","text":"<ul> <li>[ ]  Study discuss and analyze</li> <li>[ ]  Write a project definition/summary (Project Summary)</li> <li>[ ]  Set an end-results objective</li> <li>[ ]  List imperatives and deliverables</li> <li>[ ]  Generate alternative strategies</li> <li>[ ]  Evaluate alternatives</li> <li>[ ]  Choose a course of action</li> </ul>"},{"location":"template-content/project-management/project-overview/#planning-the-project","title":"Planning the Project","text":"<ul> <li>[ ]  The Three Project Parameters: Quality, Time, Cost (Risk Identification Chart)</li> <li>[ ]  Breakdown the project into logical steps or sub-units (Project Planning Summary)</li> <li>[ ]  Determine the proper sequence for each step</li> <li>[ ]  Determine time and cost for each step</li> <li>[ ]  Determine standards for each step</li> <li>[ ]  Determine resources needed, training required, staffing, and any policies or procedures</li> </ul>"},{"location":"template-content/project-management/project-overview/#implementing-the-project-plan","title":"Implementing the Project Plan","text":"<ul> <li>[ ]  Control the work in progress by monitoring and reviewing performance (Milestone Chart)</li> <li>[ ]  Provide feedback</li> <li>[ ]  Negotiate materials, supplies, and services</li> <li>[ ]  Resolve differences and changes</li> </ul>"},{"location":"template-content/project-management/project-overview/#completing-the-project","title":"Completing the Project","text":"<ul> <li>[ ]  Check that the quality specifications of the project were met</li> <li>[ ]  Evaluation review</li> </ul>"},{"location":"template-content/project-management/project-planning-summary/","title":"Project Planning Summary","text":"Component or Step Budget Schedule Resposibility"},{"location":"template-content/project-management/project-summary/","title":"Project Summary","text":"<p>Customer: [insert]</p> <p>Project name: [insert]</p> <p>Project goal: Define the high level goal of the project.</p>"},{"location":"template-content/project-management/project-summary/#objectives","title":"Objectives:","text":"<ul> <li>Break out the project goal into more specific objectives</li> <li>[insert]</li> <li>[insert]</li> </ul>"},{"location":"template-content/project-management/project-summary/#constraints","title":"Constraints:","text":"<ul> <li>Define contraints like budget, time, abilities, regulations, etc.</li> <li>[insert]</li> <li>[insert]</li> <li>[insert]</li> <li>[insert]</li> <li>[insert]</li> </ul>"},{"location":"template-content/project-management/project-summary/#risks","title":"Risks:","text":"<ul> <li>Equipment delays [SIGNIFICANT RISK]</li> <li>Over budget [MODEST RISK]</li> <li>Use \u2018Significant\u2019 or \u2018Modest\u2019 as risk levels and bold Significant risks.</li> </ul>"},{"location":"template-content/project-management/project-summary/#assumptions","title":"Assumptions:","text":"<ul> <li>List of assumtions outside the scope of the project.</li> <li>Example: Contractor will provide tools and materials</li> <li>[insert]</li> </ul>"},{"location":"template-content/project-management/project-summary/#project-scope","title":"Project Scope","text":""},{"location":"template-content/project-management/project-summary/#in-scope","title":"In Scope:","text":"<ul> <li>Define actions within the scope of the project.</li> <li>[insert]</li> <li>[insert]</li> </ul>"},{"location":"template-content/project-management/project-summary/#out-of-scope","title":"Out of Scope:","text":"<ul> <li>Define actions outside the scope of the project.</li> <li>[insert]</li> <li>[insert]</li> </ul>"},{"location":"template-content/project-management/project-summary/#deliverables","title":"Deliverables:","text":"<ul> <li>Define specific completed deliverables by the end of the project.</li> <li>[insert]</li> <li>[insert]</li> </ul>"},{"location":"template-content/project-management/project-summary/#tasks-and-estimated-costs","title":"Tasks and Estimated Costs","text":"Task Estimated Costs Notes ex. Furniture $1,000 Decorations $250 wall art TOTAL $1,250 estimated"},{"location":"template-content/project-management/project-summary/#closing-checklist","title":"Closing Checklist","text":"<ul> <li>[ ]  All Deliverables Checked and Tested for Quality Requirements</li> <li>[ ]  Deliver Documentation and/or Training (If Required)</li> <li>[ ]  Get Customer/Management/Stakeholder Sign-Off</li> <li>[ ]  Reassign Personnel, Dispose of Surplus Equipment/Materials, and Release Facilities</li> <li>[ ]  Document Project (Problems, Lessons Learned, Etc.)</li> <li>[ ]  Report Final Project Status and Outcome to Customer/Management/Stakeholders</li> <li>[ ]  Declare Project Completed</li> </ul>"},{"location":"template-content/project-management/risk-identification-chart/","title":"Risk Identification Chart","text":"Control Element What is likely to go wrong? How and when will I know? What will I do about it? Quality Cost Timeliness"}]}